/** File: RevalBase.java */
import java.*;
import java.io.*;
import java.io.FileReader;
import java.text.*;
import java.util.*;
import java.awt.*;

/**
 * Class RevalBase is an abstract base class used to define the base 
 * infrastructure for evaluating R scripts (using the R program) using
 * data supplied from a client program. It was developed with the MAExplorer
 * client program. We will refer to the "client" or client program throughout
 * this file. We may refer to the client {installation directory} and to the
 * client {project diretory} where data files are found and generated.
 * Note that one must always extend this base class using an instance of
 * Reval.java edited for the particular client program. Data will be defined
 * there that is used in this base class.
 *<P>
 * Class Reval extends RevalBase and is used to evaluate R scripts with data 
 * supplied from the client program via the MJA API. 
 * Each R analysis is defined by a R LayOut (RLO). Each RLO
 * is saved in an internal RLO database managed by the Reval MJA class
 * (see addRLO() method for details on the RLO).
 *<P>
 * R is an extensible language and envirnment for statistical computing and
 * graphics. R is Open Source (GNU public license) and is available for
 * download at www.r-project.org.
 *<P>
 * This class's methods contain a command interpreter, and support methods 
 * and data structures to enable you to execute R program .R scripts using
 * client data.
 *<p>
 * It is intended to be used when writing MAEPlugins that need to access the
 * R program to execute .R scripts with client data. This may generate
 * reports and plots (PDF, JPG, PNG, Postscript, SVG). Some of these reports 
 * may  be used to pass the R results back into the client state.
 *<P> 
 * This class evaluates R scripts with data supplied from the client via
 * the MJAReval API. Each R analysis is defined by a R LayOut (RLO). Each
 * RLO is saved in an internal RLO database managed by the mjaReval MJAReval
 * class. (See class variable definitions and addRLO() method for details 
 * on the RLO). The RLOs specify the evaluation environment for the .R 
 * script when evaluated by R. The R program is then run as a separate 
 * process using a System.exec()
 *<P>
 * The clientProgram-R interface library RLORlibr is kept in the client 
 * program {installation directory}/lib/{RLORlibr}/ and contains the 
 * standard R library format subdirectories including R/ (separate files)
 * and R-ex/ (single file). 
 *<P>
 * When an RLO script is evaluated, we copy the .R script with a "tmp-" 
 * prefix to the project Temp/ and prepend the following 2 lines:
 *<PRE>
 *   setwd("...Temp/")
 *   library({RLOR}libr,lib.loc="{installation directory}/lib")
 *</PRE>
 * which are required for the .R script to access the data generated by
 * the client program and to access the library.
 *<P>
 * When executed, an R script is allowed to generate multiple output files 
 * that may include the following formats: text, tab-delimited text, PDF, 
 * JPG, etc. There may be also multiple data input files requested by the
 * R script. These are generated by mjaReval class methods as specified by
 * the RLO database entry. Note: during R execution, all files are read and
 * written from the {project}/Temp directory, the R current working 
 * directory. They may be copied to or from this directory from or to 
 * other directories as required.
 *<PRE>
 * 1. data is exported from the client program to tab-delimited data input
 *    files {Project}/Temp/. These will then be read by R when your script
 *    is evaluated.
 * 2. The output of R is saved to any number of files into the 
 *    {project directory}/Temp/ and then moved to the
 *    {Project directory}/Report/ where they may then be displayed or 
 *    read by the client program if required.
 * 3. The .R scripts are shared with all instances of the client program
 *    and are kept in {installation directory}/R/
 * 4. The .rlo files are shared by all instances of the client program and
 *    are kept in {installation directory}/RLO/ directory.
 * 5. The startup script is generated by an mjaReval method and placed in
 *    the {project directory}/Temp directory where it will be used by a 
 *    System.exec() call.
 *</PRE>
 * This work was produced by Peter Lemkin of the National Cancer
 * Institute, an agency of the United States Government.  As a work of
 * the United States Government there is no associated copyright.  It is
 * offered as open source software under the Mozilla Public License
 * (version 1.1) subject to the limitations noted in the accompanying
 * LEGAL file. This notice must be included with the code. The MAExplorer 
 * Mozilla and Legal files are available on http://maexplorer.sourceforge.net/.
 *<P>
 * @author P. Lemkin (NCI), G. Thornwall (SAIC), NCI-Frederick, Frederick, MD
 * @version $Date: 2004/01/13 16:46:20 $   $Revision: 1.2 $
 * @see <A HREF="http://maexplorer.sourceforge.net/">MAExplorer Home</A>
 * @see Reval
 * @see RLO
 */
  
  public abstract class RevalBase
  {
   /** DEBUG flag for RevalBase */
   final static boolean 
      REB_DBUG= true;
    
   /** Name of the client program */
   String
     clientName;
   /** Name of the R2Client prefix */
   String 
     r2ClientPrefix;
           
   /** file name used with popup file browser */
   String
     promptFile;
   /** directory used with popup file browser */
   String
     promptDir;
   /** file extension used with popup file browser */
   String
     promptExt;                
  
  /** current name of "name=value" pair for StringTokenizer */
  private String
    parseName;
  /** current value of "name=value" pair for StringTokenizer*/
  private String             
    parseValue;         
  /** current delim of "name(delim)value" pair for StringTokenizer*/
  private int
    parseDelimChar;
       
   /** Flag set debugging - toggled by dbugCheckbox if DBUG_FLAG is set */
   boolean 
     dbugFlag;
   
   /** Flag to use S-Plus, else use R. This is needed if both R
    * and S-Plus are on the same system. The default is FALSE and
    * is to use R.
    */
   boolean 
     useSPlusFlag;
   
   /** Flag for RLO Report logging by creating subdirectory in
    * {project}/Report/{RLOname}-yymmdd.hhmmss/ 
    * to store the RLO output files copied to Report/
    */
   boolean 
     useRLOloggingFlag;
   /** Name of RLO Report logging by creating subdirectory 
    * {project}/Report/{RLOname}-yymmdd.hhmmss/ 
    * to store the RLO output files copied to Report/
    */
   String
     rloReportLoggingFile;
   
   /** time stamp dir for reports */
    String
      timeStampReportDir="";
     
   static String
     javaHome,       /**  JDK getProperty("java.home") */
     osName,         /**  JDK getProperty("os.name") */
     fileSeparator,  /**  JDK getProperty("file.separator") */
     userDir;        /**  JDK Property("user.dir")+fileSep */  
  
   /** Flag set if running on a Windows computer */
   static boolean 
     isWindowsFlag;      
    
   /* ---------- Status of RLO database ----------- */      
   /** current RLO version number for I/O */
   final static String
     RLO_VERSION= "RLO-1.0";
   /** default # of analyses allowed */
   final static int
     MAX_ANALYSES= 200;
   /** List [0:nAnalyses-1] of R analysis procedures descriptions */
   static RLO
     analyses[]= null;
   /** # of Rscript analysis procedures */
   static int
     nAnalyses= 0;
   /** max # of Rscript analysis procedures */
   static int
     maxRLO= 0;
   /** Current analysis procedure being used from the analyses[] list */
   static int
     curAnalysis= 0;  
    
  /* --------------------------------------------------- */
  /* File names and paths                                */
  /* --------------------------------------------------- */
  
  /** default output file for R to save any output 
   * if we do not specify an output file for the current
   * analysis.
   */
  final private static String
    DEFAULT_R_OUTPUT_FILE= "ClientRoutputDefault.txt"; 
  
  /** This is the name of the path for the saved R base path
   * in the Temp/.RbasePath file it it ever tried to prompt
   * for the R base path and there was no response to the\
   * prompt. This means R is not installed.
   */
  final private static String 
    NO_R_INSTALLED= "**NO_R_INSTALLED**";
    
  /** path of {client project} Report/ directory */    
  static String
    reportBasePath;
  /** path of {client installation} R/ directory */    
  static String
    RscriptBasePath;
  /** path of {client installation} RLO/ directory */    
  static String
    RLObasePath;
  /** path of {client project} Temp/ directory */    
  static String
    tempBasePath;
  /** base path of where {client installation} R project RLORlibr/ 
   * directory lives */    
  static String
    clientRlibrBasePath;  
  /** Clients R project RLORlibr/ directory lives. Default to "RLORlibr" */    
  static String
    RLORlibr;  
  
  /** base bin Path to R executable if it exists.
   * E.g., "C://R/bin/", or "C://Program Files/R/bin,  or
   * "/usr/opt/R/bin/",  etc. 
   */
  static String   
    RbinBasePath;
  /** base bin Path to S-Plus executable if it exists.
   * e.g., "C://Program Files/insightful/splus61/cmd/",  or
   * "/usr/opt/insightful/splus61/cmd/", etc. 
   */
  static String   
    SPlusBinBasePath;
  
  /** user's home directory for e.g.env "R_USER" or "HOME"
   * or "C:/R/", etc.
   * Note: R_USER may not be defined, in which case it defaults to the 
   * starting directory i.e. C:/R/" or C:/Program Files/{client program}".
   * This is potentially a problem, since in a shared system, the user
   * may not have admin access. In that case they need to explicitly set
   * the env variable "R_USER" to the {project}/Temp where the are working.
   */
  static String   
    RuserBasePath;  
  
  /** base Path to R executable e.g. "C://R/" */
  static String   
    RbasePath;   
  
  /** base path to S-Plus executable e.g. "C://Program files/splus61/" */
  static String   
    SPlusBasePath;  
  
  /** If the flag is set then add "\ ...\" around exec program
   *    "\"" + RbinBasePath + ("Rterm" or "splus") + "\"" <B>BEFORE</B> exec
   */
  static boolean
    quoteRunPathFlag;
   
  /* Name of current .R input script file */
  static String
    inputRscriptFileName;
  
  /** name of current batch R startup script file to exec() by the OS */
  static String  
    startupRscriptFileName;
  /** path of Text report file in Report/ if doing a "SaveAs" of TextArea */ 
  static String
    reportFileName;
  
  /** full path of batch R startup script file  */
  static String  
    fullRunRfilePath;
  /** full path of .R input script file  */
  static String  
    fullRscriptInputPath;
  /** full path of R output file  */
  String  
    fullRoutputFilePath;
   
  /** If createInputDataFiles() failed, this is a suggestion on how 
   * to fix the problem.
   */
  String
    specificCreateInputFileProblem;
   
   /* --------------------------------------------------- */
   /* R state and resources                               */
   /* --------------------------------------------------- */
    
   /** Input {client project} data type required for R analysis for 
    * specifying inputDataTypes[] entries in the RLO analyses[] instances.
    * These will be extracted into a tab-delimited array and placed in a
    * data input file as input for R.
    */
   /** client export data file types names for import to R */
   static String
     rDataTypeName[]= null;
   /** client export data file types menu entries for import to R */
   static String
     rDataTypeMenu[]= null;
   /** client export data file types values for import to R */
   static int
     rDataTypeVal[]= null;
   /** Number of client export data file types for import to R */
   static int
     nRdataTypes= 0;   
  
  /** Output Data types required for R analysis for specifying either
   * inputDataTypes[] or outputDataTypes[] entries in the
   * RLO analyses[] instances. The plugin write can then use
   * these to drive additional actions on the R output. E.g., popup
   * a view for plot output etc.
   */
   /** R output file types names */
   static String
     rOfileTypeName[]= null;
   /** R output file types menu entries */
   static String
     rOfileTypeMenu[]= null;
   /** R output file types values */
   static int
     rOfileTypeVal[]= null;
   /** Number of R output file types */
   static int
     nOfileTypes= 0;
   /** Special StdOut Output File type needed for RevalBase class */
   static int
     rOfileTypeStdOut= 0;
  
  /* The setR2ClientXXXXX define the actions to be taken when setting R 
   * computed data (i.e. output files) back to client objects.
   * The RLO parallel data is setR2ClientFileNames[], setR2ClientObjNames[], 
   * setR2ClientObjTypes[] entries in the RLO analyses[] instances.
   */  
   /** R2Client actions names */
   static String
     r2ClientActionName[]= null; 
   /** R2Client actions menu entries */
   static String
     r2ClientActionMenu[]= null; 
   static int
     r2ClientActionVal[]= null;
   /** Number of R2Client actions */
   static int
     nR2ClientActions= 0;     
  
  /* Process Bits (PB) required for R analysis for specifying the
   * processBit entry in the RLO analyses[] instances.
   * It is used both for specifying eval-time processing and restrictions
   * on client data. These bits are OR'ed together and saved in the RLO 
   * genRbits field.
   * [OLD]  R_PB_USE_xxxxx
   * [NOTE} special handling of R_PB_USE_VANILLA_R "vanilla" for generating
   *        "--vanilla" switch for starting R.
   */
   /** R2Client actions names */
   static String
     rProcessBitName[]= null;
   /** Process Bits to use Menu entries */
   static String
     rProcessBitMenu[]= null;
   /** Process Bits to use values */
   static int
     rProcessBitVal[]= null;
   /** Number of R2Client actions */
   static int
     nProcessBits= 0;
   
   /** Special process bit needed for RevalBase class */
   static int
     rPB_useVanillaBit= 0;
   
  /** instance of the RLO database.*/
  RLO
    rlo;
  
  /** Report text that results from running an R script. This text
   * is read back from the Report/ if an R_FILE_TYPE_REPORT was
   * specified for that analysis. If there is an error in performing
   * the eval, then rReport may contain that error.
   */
  String
    rReport= null; 
  
  /** Stdout (and stderr) text that results from running an R script. 
   * This text is captured during the eval of the R script.
   */
  String
    rStdout= null;  
  
  
  /**
   * RevalBase() - constructor for initial database allocation
   * @param clientName is the name of the client that is calling us
   * @param r2ClientPrefix is the name of the client that is calling us
   * @param RLORlibr is the name of the client's R library, it defaults
   *        to "RLORlibr" if not specified.
   * @param maxAnalyses to set up the database
   */
  RevalBase(String clientName, String r2ClientPrefix, String RLORlibr,
            int maxAnalyses)
  { /* RevalBase*/ 
    this.clientName= (clientName==null) ? "Client" : clientName;
    this.r2ClientPrefix= (r2ClientPrefix==null) 
                            ? "R2Client" : r2ClientPrefix;
    this.RLORlibr= (RLORlibr==null) ? "RLORlibr" : RLORlibr;
    
    javaHome= System.getProperty("java.home");
    osName= System.getProperty("os.name");
    fileSeparator= System.getProperty("file.separator");
    userDir= System.getProperty("user.dir")+fileSeparator; 
    isWindowsFlag= osName.startsWith("Windows");  
    
    useSPlusFlag= false;          /* default to use R */
    useRLOloggingFlag= false;     /* Default is NO rlo logging */
    rloReportLoggingFile= null;
    
    dbugFlag= false;              /* default is no debugging */
    
    /* clear the (name,value) databases. */
    rDataTypeName= null;
    rDataTypeMenu= null;
    rDataTypeVal= null;
    nRdataTypes= 0;
    
    rOfileTypeVal= null;
    rOfileTypeName= null;
    nOfileTypes= 0;
    
    r2ClientActionName= null;
    r2ClientActionMenu= null; 
    r2ClientActionVal= null;
    nR2ClientActions= 0;
    
    rProcessBitName= null;
    rProcessBitMenu= null;
    rProcessBitVal= null;
    nProcessBits= 0;

    rlo= new RLO(this, maxAnalyses);
    
    reportFileName= "";     
  } /* RevalBase*/
  
  
  /**
   * setRdataTypeDB() - set the export-types (name,menu,type) database.
   * These files are output by the client and read by R.
   * @param names is list of file names output by client and read by R
   * @param menus is list of menu entries
   * @param values is list of corresponding values
   * @return true if succeed
   */
  boolean setRdataTypeDB(String names[], String menus[], int values[])
  { /* setRdataTypeDB */
    if(names==null)
      return(false);
    rDataTypeName= names;
    rDataTypeMenu= menus;
    rDataTypeVal= values;
    nRdataTypes= names.length;
    return(false);
  } /* setRdataTypeDB */
  
  
  /**
   * setOfileTypeDB() - set the R output file-types (name,menu,type) database.
   * These files are output by R.
   * @param names is list of file names output by R
   * @param menus is list of menu entries
   * @param values is list of corresponding values
   * @return true if succeed
   */
  boolean setOfileTypeDB(String names[], String menus[], int values[])
  { /* setOfileTypeDB */
    if(names==null)
      return(false);
    rOfileTypeName= names;
    rOfileTypeMenu= menus;
    rOfileTypeVal= values;
    nOfileTypes= names.length;
    
    /* Special StdOut Output File type needed for RevalBase class */
    rOfileTypeStdOut= 0;
    for(int i=0;i<nOfileTypes;i++)
      if(rOfileTypeName[i].indexOf("Stdout")!=-1)
      {
        rOfileTypeStdOut= rOfileTypeVal[i];
        break;
      }
    return(false);
  } /* setOfileTypeDB */
  
  
  /**
   * setR2ClientActionDB() - set the R to client Actions (name,menu,type)
   * database.
   * @param names is list of names of actions
   * @param menus is list of menu entries
   * @param values is list of corresponding type values
   * @return true if succeed
   */
  boolean setR2ClientActionDB(String names[], String menus[], int values[])
  { /* setR2ClientActionDB */
    if(names==null)
      return(false);
    r2ClientActionName= names;
    r2ClientActionMenu= menus; 
    r2ClientActionVal= values;
    nR2ClientActions= names.length;
    return(true);
  } /* setR2ClientActionDB */  
  
  
  /**
   * setProcessBitsDB() - set the Export/Import ProcessBits 
   *    (name,menuOn,menuOFF,type) database.
   * @param names is list of names
   * @param menus is list of menu entries
   * @param values is list of corresponding values
   * @return true if succeed
   */
  boolean setProcessBitsDB(String names[], String menus[], int values[])
  { /* setProcessBitsDB */
    if(names==null)
      return(false);
    rProcessBitName= names;
    rProcessBitMenu= menus;
    rProcessBitVal= values;
    nProcessBits= names.length;
        
    rPB_useVanillaBit= 0;
    for(int i=0;i<nProcessBits;i++)
      if(rProcessBitName[i].indexOf("--vanilla")!=-1)
      {
        rPB_useVanillaBit= rProcessBitVal[i];
        break;
      }
    
    return(true);
  } /* setProcessBitsDB */
  
  
  /**
   * lookupRdataTypeDBmenu() - lookup the export-types menu entry by name.
   * @param name is the file name to lookup
   * @return menu else null if not found
   */
  String lookupRdataTypeDBmenu(String name)
  { /* setRdataTypeDBmenu */
    for(int i=0;i<nRdataTypes;i++)
      if(rDataTypeName[i].equalsIgnoreCase(name))
      {
        return(rDataTypeMenu[i]);
      }
    if(REB_DBUG)
      System.out.println("REB-lookupRdataTypeDBmenu("+name+"') not found");
    return(null);
  } /* lookupRdataTypeDBmenu */
  
  
  /**
   * lookupRdataTypeDBmenu() - lookup the export-types menu entry by value.
   * @param value is the file name to lookup
   * @return menu else null if not found
   */
  String lookupRdataTypeDBmenu(int val)
  { /* setRdataTypeDBmenu */
    for(int i=0;i<nRdataTypes;i++)
      if(rDataTypeVal[i]==val)
      {
        return(rDataTypeMenu[i]);
      }
    if(REB_DBUG)
      System.out.println("REB-lookupRdataTypeDBmenu("+val+"') not found");
    return(null);
  } /* lookupRdataTypeDBmenu */
  
  
  /**
   * lookupRdataTypeDBvalue() - lookup the export-types value by name.
   * @param name is the file name to lookup
   * @return value else 0 if not found
   */
  int lookupRdataTypeDBvalue(String name)
  { /* setRdataTypeDB */
    for(int i=0;i<nRdataTypes;i++)
      if(rDataTypeName[i].equalsIgnoreCase(name))
      {
        return(rDataTypeVal[i]);
      }
    if(REB_DBUG)
      System.out.println("REB-lookupRdataTypeDBvalue("+name+"') not found");
    return(0);
  } /* lookupRdataTypeDBvalue */
  
  
  /**
   * lookupOfileTypeDBmenu() - lookup R output file type menu entry by name.
   * @param name is the file name to lookup
   * @return menu else null if not found
   */
  String lookupOfileTypeDBmenu(String name)
  { /* lookupOfileTypeDBmenu */
    for(int i=0;i<nOfileTypes;i++)
      if(rOfileTypeName[i].equalsIgnoreCase(name))
      {
        return(rOfileTypeMenu[i]);
      }
    if(REB_DBUG)
      System.out.println("REB-lookupOfileTypeDBmenu("+name+"') not found");
    return(null);
  } /* lookupOfileTypeDBmenu */
  
  
  /**
   * lookupOfileTypeDBmenu() - lookup R output file type menu entry by value.
   * @param val is the entry value
   * @return menu else null if not found
   */
  String lookupOfileTypeDBmenu(int val)
  { /* lookupOfileTypeDBmenu */
    for(int i=0;i<nOfileTypes;i++)
      if(rOfileTypeVal[i]==val)
      {
        return(rOfileTypeMenu[i]);
      }    
    if(REB_DBUG)
      System.out.println("REB-lookupOfileTypeDBmenu("+val+"') not found");
    return(null);
  } /* lookupOfileTypeDBmenu */
    
  
  /**
   * lookupOfileTypeDBvalue() - lookup R output file type value by name.
   * @param name is the file name to lookup
   * @return value else 0 if not found
   */
  int lookupOfileTypeDBvalue(String name)
  { /* lookupOfileTypeDBvalue */
    for(int i=0;i<nOfileTypes;i++)
      if(rOfileTypeName[i].equalsIgnoreCase(name))
      {
        return(rOfileTypeVal[i]);
      }
    if(REB_DBUG)
      System.out.println("REB-lookupOfileTypeDBvalue("+name+"') not found");
    return(0);
  } /* lookupOfileTypeDBvalue */
  
  
  /**
   * lookupR2ClientActionDBMenu() - lookup R to client Action menu by name
   * @param name is the name of entry
   * @return menu else null if not found
   */
  String lookupR2ClientActionDBMenu(String name)
  { /* lookupR2ClientActionDBMenu */
    for(int i=0;i<nR2ClientActions;i++)
      if(r2ClientActionName[i].equalsIgnoreCase(name))
      {
        return(r2ClientActionMenu[i]);
      }
    if(REB_DBUG)
      System.out.println("REB-lookupR2ClientActionDBMenu("+name+"') not found");
    return(null);
  } /* lookupR2ClientActionDBMenu */ 
  
  
  /**
   * lookupR2ClientActionDBMenu() - lookup R to client Action menu by value
   * @param value is of the action
   * @return menu else null if not found
   */
  String lookupR2ClientActionDBMenu(int val)
  { /* lookupR2ClientActionDBMenu */
    for(int i=0;i<nR2ClientActions;i++)
      if(r2ClientActionVal[i]==val)
      {
        return(r2ClientActionMenu[i]);
      }
    if(REB_DBUG)
      System.out.println("REB-r2ClientActionMenu("+val+"') not found");
    return(null);
  } /* lookupR2ClientActionDBMenu */ 
  
  
  /**
   * lookupR2ClientActionDBvalue() - lookup R to client Action value by name
   * @param name is the name of entry
   * @return menu else 0 if not found
   */
  int lookupR2ClientActionDBvalue(String name)
  { /* lookupR2ClientActionDBvalue */
    for(int i=0;i<nR2ClientActions;i++)
      if(r2ClientActionName[i].equalsIgnoreCase(name))
      {
        return(r2ClientActionVal[i]);
      } 
    if(REB_DBUG)
      System.out.println("REB-lookupR2ClientActionDBvalue("+name+"') not found");
    return(0);
  } /* lookupR2ClientActionDBvalue */ 
  
  
  /**
   * lookupProcessBitsDBmenu() - lookup Export/Import ProcessBits menu 
   * by value
   * @param i is ith process bit
   * @param value is of the process bit
   * @return menu else null if not found
   */
  String lookupProcessBitsDBmenu(int i, int val)
  { /* lookupProcessBitsDBmenu */
    if(i<=0 || i>=nProcessBits)
      return(null);
    int bit= rProcessBitVal[i];
    String sR= ((bit!=0) ? "On: " : "Off: ") + rProcessBitMenu[i];
      
    return(sR);
  } /* lookupProcessBitsDBmenu */ 
  
  
  /**
   * lookupR2ClientActionDBtype() - lookup R to client Action type value
   * by name
   * @param name is name of the action
   * @return value else 0 if not found
   */
  int lookupR2ClientActionDBtype(String name)
  { /* lookupR2ClientActionDBtype */
    for(int i=0;i<nR2ClientActions;i++)
      if(r2ClientActionName[i].equalsIgnoreCase(name))
      {
        return(r2ClientActionVal[i]);
      } 
    if(REB_DBUG)
      System.out.println("REB-lookupR2ClientActionDBtype("+name+"') not found");
    return(0);
  } /* lookupR2ClientActionDBtype */
  
  
  /**
   * lookupProcessBitsDBvalue() - lookup the Export/Import ProcessBits value
   * by name
   * @param name is the name to lookup
   * @return value if found, 0 if not found.
   */
  int lookupProcessBitsDBvalue(String name)
  { /* lookupProcessBitsDBvalue */
    for(int i=0;i<nProcessBits;i++)
      if(rProcessBitName[i].equalsIgnoreCase(name))
      {
        return(rProcessBitVal[i]);
      }
    if(REB_DBUG)
     System.out.println("REB-lookupProcessBitsDBvalue("+name+"') not found");
    return(0);
  } /* lookupProcessBitsDBvalue */
  
   
   /**
    * cvtInputType2Str() - convertinput file type R_FILE_TYPE_xxxx to string
    * @param val to convert
    * @return string name if found, else "Illegal"
    */
   String cvtInputType2Str(int val)
   { /* cvtInputType2Str */
     String sR= lookupRdataTypeDBmenu(val);
     if(sR==null)
       sR= "Illegal";
     return(sR);
   } /* cvtInputType2Str */
   
   
   /**
    * cvtOutType2Str() - convert output file type  to string
    * @param val to convert
    * @return string name if found, else "Illegal"
    */
   String cvtOutType2Str(int val)
   { /* cvtOutType2Str */
     String sR= lookupOfileTypeDBmenu(val);
     if(sR==null)
       sR= "Illegal";
     return(sR);
   } /* cvtOutType2Str */
   
   
   /**
    * cvtR2ClientType2Str() - convert R2Client file type R to string
    * @param val to convert
    * @return string name if found, else "Illegal"
    */
   String cvtR2ClientType2Str(int val)
   { /* cvtR2ClientType2Str */
     String sR= lookupR2ClientActionDBMenu(val);
     if(sR==null)
       sR= "Illegal";
     return(sR);
   } /* cvtR2ClientType2Str */
  
      
  /**
   * getRdataTypeDBnames() - get the R input file type names
   * @return list of names
   */
  String[] getRdataTypeDBnames()
  { return(rDataTypeName); }  
  
  
  /**
   * getRdataTypeDBmenus() - get the R input file type menus
   * @return list of menu entries
   */
 String[] getRdataTypeDBmenus()
  { return(rDataTypeMenu); } 
  
  
  /**
   * getRdataTypeDBtypes() - get the R input file type values
   * @return list of values
   */
  int[] getRdataTypeDBtypes()
  { return(rDataTypeVal); }
  
  
  /**
   * getOfileTypeDBnames() - get the R output file type names 
   * @return list of file names
   */
  String[] getOfileTypeDBnames()
  { return(rOfileTypeName); }  
  
  
  /**
   * getOfileTypeDBmenus() - get the R output file type menu  
   * @return list of menu entries
   */
  String[] getOfileTypeDBmenus()
  { return(rOfileTypeMenu); }  
  
  
  /**
   * getOfileTypeDBtypes() - get the R output file names type values
   * @return list of values
   */
  int[] getOfileTypeDBtypes()
  { return(rOfileTypeVal); }
    
  
  /**
   * getR2ClientActionDBnames() - get R to client Actions DB names
   * @return list of names
   */
  String[] getR2ClientActionDBnames()
  { return(r2ClientActionName); }
    
  
  /**
   * getR2ClientActionDBmenus() - get R to client Actions DB menus
   * @return list of menu entries
   */
  String[] getR2ClientActionDBmenus()
  { return(r2ClientActionMenu); }
  
  
  /**
   * getR2ClientActionDBtypes() - get R to client Actions DB type values
   * @return list of values
   */
  int[] getR2ClientActionDBtypes()
  { return(r2ClientActionVal); }

  
  /**
   * getProcessBitsDBnames() - get Export/Import ProcessBits DB names
   * @return list of names
   */
  String[] getProcessBitsDBnames()
  { return(rProcessBitName); }

  
  /**
   * getProcessBitsDBmenus() - get Export/Import ProcessBits DB menus
   * entries
   * @return list of menu entries
   */
  String[] getProcessBitsDBmenus()
  { return(rProcessBitMenu); }
  
  
  /**
   * getProcessBitsDBvalues() - get  Export/Import ProcessBits DB values
   * @return list of values
   */
  int[] getProcessBitsDBvalues()
  { return(rProcessBitVal); }
  
    
  /** 
   * setRLOreportLoggingFlag() - set RLO Report logging flag for
   * creating subdirectory in {project}/Report/{RLOname}-yymmdd.hhmmss/ 
   * to store the RLO output files copied to Report/
   */
  void setRLOreportLoggingFlag(boolean flag)
  { useRLOloggingFlag= flag; }
  
    
  /** 
   * setDbugFlag() - set debugging flag to print to stdout if required
   */
  void setDbugFlag(boolean flag)
  { dbugFlag= flag; }
  
    
  /**
   * setupAllBasePaths() - generate all base paths of directories
   * <PRE>
   * 1. RbinBasePath is the executable bin directory for 
   *    running R in <R installation>,
   * 2. reportBasePath for saving reports in {project}/Report/, 
   * 3. RscriptBasePath is the {client installation}/R/
   *    for .R scripts, 
   * 4. tempBasePath is the {project directory}/Temp/ directory used for 
   *    R data input,
   * 5. clientRlibrBasePath is "<client installation>/lib"
   *    dir where R project RLORlibr/ directory lives  
   * </PRE>
   * @param clientPrjPath is the client project base path
   * @return true if succeed
   * @see #setupRbinPath
   */
   boolean setupAllBasePaths(String clientPrjPath)
   { /* setupAllBasePaths */   
     boolean flag= true;
     
    /* [1] Generate base paths and create directories for user {project} 
     * if required 
     */    
    
    reportBasePath= clientPrjPath + "Report" + fileSeparator; /* <project>*/
    tempBasePath= clientPrjPath + "Temp" + fileSeparator;    /* <project> */  
 
    RscriptBasePath= userDir + "R" + fileSeparator; /* <Client installation>*/
    RLObasePath= userDir + "RLO" + fileSeparator;   /* <Client installation>*/
    clientRlibrBasePath= cvtBackslash2Fwdslash(userDir+"lib");
                                           /* "<Client installation> /lib" */
    try
    {
    File 
      fReport= new File(reportBasePath),
      fRscript= new File(RscriptBasePath),
      fRLO= new File(RLObasePath),
      fTemp= new File(tempBasePath);
    
    /* Create directories if they do not exist */
    if(! fReport.isDirectory())
      fReport.mkdirs();             /* create "Report/" directory */
    if(! fRscript.isDirectory())
      fRscript.mkdirs();            /* create "R/" directory */
    if(! fRLO.isDirectory())
      fRLO.mkdirs();                /* create "RLO/" directory */
    if(! fTemp.isDirectory())
      fTemp.mkdirs();               /* create "Temp/" directory */
    }
    catch(Exception e)
    {       
      e.printStackTrace();
      flag= false;
    }
   
    /* [2] Setup base path to R executable directory where the R 
     * executable binary is located.
     */ 
    if(flag)
    {
      RbinBasePath= setupRbinPath(true /* prompt if R is not found */); 
      if(RbinBasePath==null)
        flag= false;
    }
     
    /* [3] Setup the "R_USER" home directory which is where R will put output
     * and get input files. The user's home directory for e.g.env "R_USER" or
     * "HOME" or "C:/R/", etc.
     * Note: R_USER may not be defined, in which case it defaults to the
     * starting directory i.e. C:/R/" or C:/Program Files/{client}".
     * This is potentially a problem, since in a shared system, the user
     * may not have admin access. In that case they need to explicitly set
     * the env variable "R_USER" to the {project}/Temp where the are working.
     */
    RuserBasePath= System.getProperty("R_USER");
    //if(RuserBasePath==null)
    //  RuserBasePath= System.getProperty("HOME");    
    if(RuserBasePath==null)
      System.setProperty("R_USER",tempBasePath);  
    RuserBasePath= System.getProperty("R_USER"); 
    //RuserBasePath= userDir;
    
    if(dbugFlag)
      System.out.println("\nREB-SAP - clientPrjPath='"+clientPrjPath+"'"+
                         "\n reportBasePath='"+reportBasePath+"'"+
                         "\n RscriptBasePath='"+RscriptBasePath+"'"+
                         "\n tempBasePath='"+tempBasePath+"'"+
                         "\n RuserBasePath='"+RuserBasePath+"'"+
                         "\n RbinBasePath='"+RbinBasePath+"'"+ 
                         "\n clientRlibrBasePath='"+
                         clientRlibrBasePath+"'\n"); 
    
    return(flag);
  } /* setupAllBasePaths */
   
  
  /**
   * cvtBackslash2Fwdslash() - convert '\\' to '/' in the string
   * @param sInput is input string
   * @param return converted string
   */
  private static String cvtBackslash2Fwdslash(String sInput)
  { /* cvtBackslash2Fwdslash */
    if(sInput==null)
      return(null);
    char
      cBuf[]= sInput.toCharArray();     /* cvt input string to char[]*/
    int lth= sInput.length();
    
    for(int i=0;i<lth;i++)
      if(cBuf[i]=='\\')
        cBuf[i]= '/';                  /* replace it */
    
    String sOut= new String(cBuf);
    
    return(sOut);
  } /* cvtBackslash2Fwdslash */    
  
  
  /**
   * simpleLookupRprogramPath() - lookup RbinBasePath by analyzing OS env
   * vars and OS name.
   * @return R bin path, else null if failed to find it in the obvious places
   */
  static String simpleLookupRprogramPath()
  { /* simpleLookupRprogramPath */ 
    quoteRunPathFlag= false;
    String backupBasePath= tempBasePath + ".RbasePath";
     
    /* [1] Try to get the R path from the environment variable */    
     cvtEnvPaths2Properties();     
     RbasePath= System.getProperty("R_HOME");  /* where R program lives */
     
     if(RbasePath!=null && isWindowsFlag)
     {
       RbinBasePath= RbasePath + fileSeparator + "bin"+ fileSeparator;
       quoteRunPathFlag= (RbinBasePath.indexOf(" ")!=-1);
     }
     
     /* [2] Otherwise, look around to see if you can discover it.
      * the <RbasePath> is the primary R directory.
      * The executable is in <RbinBasePath>/Rterm{.exe,.bin,*} depending 
      * on the OS. We want the <RbinBasePath> - not the full path
      * that includes the Rterm program.
      * For windows, there may be several releases in the R/ 
      * (e.g., rw1061/, rw1062/, etc), if so, use highest number rwxxxx/.
      */
     if(RbasePath==null)
     { /* not found as "R_HOME", look around their system */
       if(isWindowsFlag)
       { /* On Windows with its gatesian paths */
         String RtopPath= null;
         /* Look in "C:\\R\\rw????" and "C:\\\"Program Files\"\\R\\rw????" */
         if((new File("C:\\Program Files\\R\\")).isDirectory())
         { /* use it but set quoteRunPathFlag */
           RtopPath= "C:\\Program Files\\R\\";
           quoteRunPathFlag= true;
         }
         else if((new File("C:\\R\\")).isDirectory())
           RtopPath= "C:\\R\\";
         
         /* For Windows only, need to explore the rw???? subdirectory */
         if(RtopPath!=null)
         { /* see if it is rw????, etc */
           /* [2.1] get list of files and convert to string array */
           String 
              topPathFile= RtopPath,
              Rdirectory[]= null;
           try
           { /* try to read the R directory */
             File f= new File(topPathFile);
             if(f.isDirectory() && f.canRead())
               Rdirectory= f.list();
           
             if(Rdirectory!=null)
             {
               /* [2.2] sort descending from highest numbered version */
               Rdirectory= sortArray(Rdirectory, false /* descending*/);
               /* [2.3] pick 1st entry. */
               RbasePath= RtopPath + Rdirectory[0];
             }           
           } /* try to read the R directory */
           catch (Exception e)
           { /* just do it the hard way and GUESS! */
             RbasePath= null;
           }           
         } /* see if it is rw????, etc */
         
         /* [2.2] Add the "bin" directory to the R base path */
         if(RbasePath!=null)
           RbinBasePath= RbasePath + fileSeparator + "bin"+ fileSeparator;
       } /* On Windows with its gatesian paths */
       
       else 
       { /* On Unix boxes standard paths: Linux, Solaris, MacOS-X, etc. */
         /* Look in "/opt/bin/R/", "/opt/local/bin/R/", "/usr/bin/" 
          * "/usr/local/bin/", "/usr/local/lib/" has an executable R file"
          */
         if((new File("/opt/bin/R")).isFile())
           RbasePath= "/opt/bin/";
         else if((new File("/opt/local/bin/R")).isFile())
           RbasePath= "/opt/local/bin/";
         else if((new File("/usr/bin/R")).isFile())
           RbasePath= "/usr/bin/";
         else if((new File("/usr/local/bin/R")).isFile())
           RbasePath= "/usr/local/bin/";
         else if((new File("/usr/local/lib/R")).isFile())
           RbasePath= "/usr/local/lib/";
         if(RbasePath!=null)
           RbinBasePath= RbasePath;
       } /* On Unix boxes standard pathes: Linux, Solaris, MacOS-X, etc. */
     } /* not found as "R_HOME", look around their system */ 
     
     return(RbinBasePath);     
  } /* simpleLookupRprogramPath */
           
  
  /**
   * simpleLookupSPLUSprogramPath() - lookup SPlusBinBasePath by analyzing
   * OS env vars and OS name.
   * @return SPlus bin path, else null if failed to find it in the
   * obvious places
   */
  static String simpleLookupSPLUSprogramPath()
  { /* simpleLookupSPLUSprogramPath */ 
    quoteRunPathFlag= false;
    String backupBasePath= tempBasePath + ".SPlusBasePath";
     
    /* [1] Try to get the S-PLUS path from the environment variable */    
     cvtEnvPaths2Properties();     
     SPlusBasePath= System.getProperty("SPLUS_HOME");  /* where SPLUS
                                                        * program lives */
     
     if(SPlusBasePath!=null && isWindowsFlag)
     {
       SPlusBinBasePath= SPlusBasePath + fileSeparator + "cmd"+ fileSeparator;
       quoteRunPathFlag= (SPlusBinBasePath.indexOf(" ")!=-1);
     }
     
     /* [2] Otherwise, look around to see if you can discover it.
      * the <SPlusBasePath> is the primary R directory.
      * [NOTE] what is diff between sqpe.exe and splus.exe?)
      * The executable is in <SPlusBinBasePath>/splus{.exe,.bin,*} depending 
      * on the OS. We want the <SPlusBinBasePath> - not the full path
      * that includes the spqe program.
      */
     if(SPlusBasePath==null)
     { /* not found as "SPLUS_HOME", look around their system */
       if(isWindowsFlag)
       { /* On Windows with its gatesian paths */
         /* Look in "C:\\insightful\\splus6*\\" and 
          * "C:\\\"Program Files\"\\insightful\\splus6*\\" 
          * directories.
          */
         if((new File("C:\\Program Files\\insightful\\splus61\\")).isDirectory())
         { /* use it but set quoteRunPathFlag */
           SPlusBasePath= "C:\\Program Files\\insightful\\splus61\\";
           quoteRunPathFlag= true;
         }
         else if((new File("C:\\Program Files\\insightful\\splus6\\")).isDirectory())
         { /* use it but set quoteRunPathFlag */
           SPlusBasePath= "C:\\Program Files\\insightful\\splus6\\";
           quoteRunPathFlag= true;
         }
         else if((new File("C:\\insightful\\splus61\\")).isDirectory())
           SPlusBasePath= "C:\\insightful\\splus61\\";
         else if((new File("C:\\insightful\\splus6\\")).isDirectory())
           SPlusBasePath= "C:\\insightful\\splus6\\";        
                 
         /* [2.2] Add the "cmd" directory to the SPlus base path */
         if(SPlusBasePath!=null)
           SPlusBinBasePath= SPlusBasePath + fileSeparator + "cmd"+
                             fileSeparator;
       } /* On Windows with its gatesian paths */
       
       else 
       { /* On Unix boxes standard paths: Linux, Solaris, MacOS-X, etc. */
         /* Look in "/opt/bin/splus/", "/opt/local/bin/splus/", "/usr/bin/" 
          * "/usr/local/bin/", "/usr/local/lib/" has an executable S-Plus 
          * file.
          */
         for(int k=1;k<=2;k++)
         { /* check both splus6/ and splus61/ */
           String dir= (k==1) ? "splus6" : "splus61";
           if((new File("/opt/bin/insightful/"+dir)).isFile())
             SPlusBasePath= "/opt/bin/insightful/"+dir;
           else if((new File("/opt/local/bin/insightful/"+dir)).isFile())
             SPlusBasePath= "/opt/local/bin/insightful/"+dir;
           else if((new File("/usr/bin/"+dir)).isFile())
             SPlusBasePath= "/usr/bin/insightful/"+dir;
           else if((new File("/usr/local/bin/insightful/"+dir)).isFile())
             SPlusBasePath= "/usr/local/bin/insightful/"+dir;
           else if((new File("/usr/local/lib/insightful/"+dir)).isFile())
             SPlusBasePath= "/usr/local/lib/insightful/"+dir;
         } /* check both splus6/ and splus61/ */
         if(SPlusBasePath!=null)
           SPlusBinBasePath= SPlusBasePath;
       } /* On Unix boxes standard pathes: Linux, Solaris, MacOS-X, etc. */
     } /* not found as "SPLUS_HOME", look around their system */ 
     
     return(SPlusBinBasePath);     
  } /* simpleLookupSPLUSprogramPath */
  
       
  /**
   * sortArray() - bubble sort string array either ASCENDING or DESCENDING.
   * This uses a bubble sort.
   * eg. A1, A10, A2 should be sorted as A1, A2, A10.
   * Should be able to use a RuleBasedCollator...
   * @param data array of data to be sorted
   * @param sortAscending direction of sort
   * @return the sorted list.
   */
  private static String[] sortArray(String data[], boolean sortAscending)
  { /* sortArray */
    if(data==null || data.length==1)
      return(data);
    
    int
      n,
      strCmp,
      jMin= 0,
      lth= data.length,
      lth1= lth-1;
    String
      dataJ,
      dataJ1;
    Collator col= Collator.getInstance();
    
    for(int i= 0; i<lth-1; i++)
    { /* bubble sort */
      n= jMin;
      for(int j= (lth-2); j>=n; j--)
      { /* compare data[j] with data[j+1] & swap if out of order*/
        dataJ= data[j];
        dataJ1= data[j+1];
        strCmp= col.compare(dataJ, dataJ1);
        if((sortAscending && strCmp >0) || ((!sortAscending && strCmp <0)))
        { /* swap j and j+1 index */
          data[j]= dataJ1;
          data[j+1]= dataJ;
          jMin= j;
        } /* swap j and j+1 index */
      } /* compare data[j] with data[j+1] & swap if out of order*/
    } /* bubble sort */
    
    return(data);
  } /* sortArray */
  
  
  /**
   * cvtEnvPaths2Properties() - get all system ENV variables and set them as 
   * separate Java properties so we can get them individually from 
   * System.getProperty(var) calls.
   * @return true if succeed
   */    
  private static boolean cvtEnvPaths2Properties()
  { /* cvtEnvPaths2Properties */    
    /* [1] Under Windows use "cmd /C set" else "env" for Unix type systems */ 
    String 
      osName= System.getProperty("os.name"),
      cmd= (osName.startsWith("Win")) ? "cmd /C set" : "env";    
    Properties p= System.getProperties();
    
    /* [2] Parse it into properties */
    try 
    {
      Runtime runtime= Runtime.getRuntime();
      InputStream inputStream= runtime.exec(cmd).getInputStream();
      InputStreamReader isr= new InputStreamReader(inputStream);
      BufferedReader br= new BufferedReader(isr);
      String 
        readline= br.readLine(),
        key= "",
        val= "";
      int indexE= -1;
      while(readline != null) 
      {
        indexE= readline.indexOf("=");
        if(indexE >= 0) {
          key= readline.substring(0,indexE);
          val= readline.substring(indexE+1,
          readline.length());
          p.put(key,val);
        }
        readline= br.readLine();
      }
      
      System.setProperties(p);
    } 
    catch(IOException ioe)
    {
      ioe.printStackTrace();
      return(false);
    }
        
    return(true);
  } /* cvtEnvPaths2Properties */
  
  
  /**
   * setupRbinPath() - setup RbinBasePath by analyzing OS env vars and OS
   * name.
   * This is where we will put the batch script and will do the exec() of
   * Rterm later.
   * @param promptIfNotFoundFlag to ask user where installed if not found. 
   *        If this flag is NOT set, return null if the R installation is
   *        not found.
   * @return R bin path, else null if failed to setup correctly
   * @see Util#cvtEnvPaths2Properties
   * @see #promptFileName
   */
  String setupRbinPath(boolean promptIfNotFoundFlag)
  { /* setupRbinPath */ 
    quoteRunPathFlag= false;
    
    /* [1] First do lookup the paths to R and S-Plus if they exist. If
     * neither exists, then fail. If one exists and the other does not
     * then force the useSPlusFlag to the one that exists. If both exist,
     * then use the one specified by the useSPlusFlag.
     */
    RbinBasePath= simpleLookupRprogramPath();
    SPlusBinBasePath= simpleLookupSPLUSprogramPath();
    
    if(!useSPlusFlag && RbinBasePath==null && SPlusBinBasePath!=null)
    {
      useSPlusFlag= true;                /* Force them to use SPLUS */
    }
    else if(useSPlusFlag && RbinBasePath!=null && SPlusBinBasePath==null)
    {
      useSPlusFlag= false;               /* Force them to use R */
    }
    
    String binBasePath= (!useSPlusFlag) ? RbinBasePath : SPlusBinBasePath;
    String backupBasePath= tempBasePath + 
                           ((useSPlusFlag) ? ".SPLUSbasePath" : ".RbasePath");     
    
    /* [2] If we are just testing if installation is found, then
     * return null if it is NOT found.
     */
    if(binBasePath==null && !promptIfNotFoundFlag)
      return(null);
     
    /* [3] If still can't find binBasePath, popup a file browser to have
     * them point to it.
     * Test if have file <tempBasePath>/".<system>basePath" in a cache.
     * If it exists, then use it BEFORE doing a prompt. If did a prompt,
     * then save the answer for the next time.
     */
    if(binBasePath==null)
    { /* Get the base path using the file browser */
      String newBinBasePath= readTextFromFile(backupBasePath,null);
      if(newBinBasePath==null)
      { /* have the user specify the path */
        newBinBasePath= 
           promptFileName("Specify base path (i.e. folder) for "+
                          ((useSPlusFlag) ? "S-Plus" : "R") + " program",
                          userDir, "",
                          "",           /* or "State" sub dir */
                          null,          /* file extension */
                          false,         /* saveMode*/
                          true           /* useFileDialog */
                          );
        if(newBinBasePath!=null)
        { /* make sure they specify the folder NOT the file */
          File fFolder= new File(newBinBasePath);
          if(fFolder.isFile())
            newBinBasePath= fFolder.getParent();  /* get folder NOT the file */
          writeTextToFile(backupBasePath, newBinBasePath);
          binBasePath= newBinBasePath;         
        }
      } /* have the user specify the path */
    } /* Get the base path using the file browser */     
     
    if(binBasePath==null)
    { /* put error message that they should set up "R_HOME" and restart */
      // [TODO] error msg... 
      writeTextToFile(backupBasePath, NO_R_INSTALLED);
      return(null);
    }
     
    if(binBasePath.equals(NO_R_INSTALLED))
    { /* R or SPLUS was not installed */
      return(null);
    }
    
    if(dbugFlag)
     System.out.println("RE-SRBP binBasePath= "+binBasePath);
     
     if(!useSPlusFlag) 
       RbinBasePath= binBasePath;
     else
       SPlusBinBasePath= binBasePath; 
                               
    return(binBasePath);
  } /* setupRbinPath */
  
 
  /**
   * accept() - file browser filter used to test if file should be in 
   * directory list.
   * NOTE: implements method for io.FilenameFilter.accept()
   * Checks if the file extension is promptExt
   * @param dir is the file directory
   * @param name is the name of the file
   * @return true if accept it
   * @ see FilenameFilter
   * @see #promptFileName
   */
  public boolean accept(File dir, String name)
  { /* accept */
    boolean flag= false;
    
    /* This method is verifies the validity of the dir and name */
    if(dir!=null && name!=null && dir.isDirectory() &&
       (name.lastIndexOf(promptExt)>0) &&
       ((new File(dir,name)).isFile()))
      flag= true;
    
    return(flag);
  } /* accept */
  
  
  /**
   * promptFileName() - dialog prompt for file name.
   * If useFileDialog is set use FileDialog else dialogQuery.
   * Set promptFile, and promptDir.
   * @param msg is the prompt msg
   * @param useDir is the opt. dir to use
   * @param initialFile is the opt. initial file
   * @param subDir is the opt. subdir to use
   * @param fileExt is the file extension
   * @param saveMode is the mode. Save if true else Open
   * @param useFileDialog if true else query dialog
   * @return the file name.
   * @ see FilenameFilter
   * @see #accept
   */
  public String promptFileName(String msg, String useDir,
                               String initialFile, String subDir,
                               String fileExt, boolean saveMode,
                               boolean useFileDialog)
  { /* promptFileName */
    promptDir= useDir;
    promptFile= null;
    
    /* File Dialog browser to get name  - may change dir */
    Frame fdFrame= new Frame("FileDialog");
    FileDialog fd= new FileDialog(fdFrame, msg, FileDialog.LOAD);
      
    if(promptDir!=null)
      fd.setDirectory(promptDir);
    if(initialFile!=null)
      fd.setFile(initialFile);
      
    /* Set filter to accept only files with fileExt extensions.
     * We implement
     *    java.io.FilenameFilter.accept(File dir, String name)
     */
    promptExt= fileExt;    /* used by accept() for filtering */
    if(promptExt!=null)
    {
      FilenameFilter filter= (FilenameFilter)this;
      fd.setFilenameFilter(filter);
    }
    
    fd.setVisible(true);
    
    String newFile= fd.getFile();
    if(newFile==null)
      return(null);
    promptFile= newFile;
    promptDir= fd.getDirectory();
    
    String fullPath= promptDir + promptFile;
    
    return(fullPath);
  } /* promptFileName */
  
  
  /**
   * runRscriptWithR() - compute report string by running R script through R.
   * Note: if S-Plus is to be used (and it exists on the system),
   * then useSPlusFlag is true. The fullRunRfilePath and remapped Rscript
   * will be set up to take this into account.
   * We eval the script after prepping required data into Temp/
   * for the curAnalysis by exec'ing an R or S-Plus process. 
   * After it completes, we read the output files from Report/ required by
   * the analyses[curAnalysis] specification.
   * @return results of running R script
   * @see #createTempRscript
   * @see #createInputDataFiles
   * @see #getRLOoutFile
   * @see #getCurrentRLO
   * @see #setCurrentRLO
   */
  String runRscriptWithR()
  { /* runRscriptWithR */        
    setWaitCursor(true);
    
    RLO a= rlo.getCurrentRLO();
    String 
      sR= "\n -------------- Rtest ------------";
    
    /* [1] Create file names and paths */
    startupRscriptFileName= (isWindowsFlag)
                              ? "ClientRSrun.bat" : "ClientRSrun.do";  
    fullRunRfilePath= tempBasePath + startupRscriptFileName; 
       
    if(dbugFlag)
      System.out.println("\nRE-RRWR.1 .bat fullRunRfilePath='"+
                         fullRunRfilePath+
                         "\n  fullRoutputFilePath='"+
                         fullRoutputFilePath+"'\n");      
    
    /* [1.1] The .R script is always copied to the <project>/Temp/ and
     * For a R command 
     *    "setwd(" + tempBasePath +")" and
     *    "library("+RLORlibr+",lib.loc=\"" +clientRlibrBasePath + "\")"
     * are prepended IN THE FRONT of the contents of the .R script. 
     * We name the new .R file used in the fullRscriptInputPath  
     * to be ("tmp-"+a.RscriptName).
     */
    inputRscriptFileName= a.RscriptName;
    sR= createTempRscript(inputRscriptFileName);
    if(sR!=null)
    {
      setWaitCursor(false);
      return(sR);    
    }
    
    /* [2] Write out the OS command script to start R on this data */
    String runRscriptStr= createRunRscript();    
    if(! writeTextToFile(fullRunRfilePath, runRscriptStr))
    { /* could not create the startup script */
      sR= "Can't write out .bat R/SPlus startup script ["+fullRunRfilePath+"]";
      setWaitCursor(false);
      return(sR);
    }
      
    if(dbugFlag)
      System.out.println("\nRE-RRWR.2 wrote .bat fullRscriptInputPath='"+
                         fullRscriptInputPath+"'"+
                         "\n runRscriptStr='"+runRscriptStr+"'\n");    
    
    /* [3] Create any input data files required for the current analysis 
     * in Temp/. These will be read by R when it executes our .R script. 
     * The names of the input files as specified in the analyses[curAnalysis]
     * must be hard-coded into the .R script. 
     */
     if(! createInputDataFiles(tempBasePath))
     { /* could not create the generated startup script */
       sR= "Can't create generated input data exported from "+clientName+
           ".\n"+
           clientName+
           " was not set up for the particular data mode required.\n"+
           "by your script. Define the missing data type in "+clientName+
           " and\n"+
           "try again.\n\n"+
           specificCreateInputFileProblem+"\n\n";
       setWaitCursor(false);
       return(sR);
     }
    
     /* [4] Get the stdout output Report file required for the analysis,
      * setup the file name.
      */  
    String rptFileName= rlo.getRLOoutFile(rOfileTypeStdOut,1);
    
    /* Create name of optional YYMMDD report dir */
    if(useRLOloggingFlag)
    {
      int lenStr= a.RscriptName.length()- 2;
      String dirName= a.RscriptName.substring(0,lenStr);   
      timeStampReportDir= dirName + "-" + getCurDateStr() + fileSeparator;
    }
    if(rptFileName!=null)
      if(useRLOloggingFlag)
        fullRoutputFilePath= reportBasePath + timeStampReportDir +
                             rptFileName;
      else
        fullRoutputFilePath= reportBasePath + rptFileName;
    else
      if(useRLOloggingFlag)
        fullRoutputFilePath= reportBasePath + timeStampReportDir + 
                             DEFAULT_R_OUTPUT_FILE;
      else
        fullRoutputFilePath= reportBasePath + DEFAULT_R_OUTPUT_FILE;
    
     /* [4.1] Create time stamp dir if does not exist */      
      if(useRLOloggingFlag)
      {
        try
        {                
          String
            reportPath= reportBasePath+timeStampReportDir;         
          File fReport= new File(reportPath); 
          if(!fReport.isDirectory())
            fReport.mkdirs();             /* create "Report/" directory */
        }
        catch(Exception e) 
        {
          e.printStackTrace();
        }
      }/* time stamp dir */
    
    /* [5] Run R on our script and get the output data into sR to return */  
    rStdout= execRscript();
    if(dbugFlag)
      System.out.println("rStdout='"+rStdout+"'");
    
    /* [6] Copy the output file from Report/ to sR output string. 
     * Find the name of the output Report file - pick first one.
     */
     sR= readTextFromFile(fullRoutputFilePath,null);
     if(sR==null)    
       sR= "There was a problem reading the R output file\n  ["+
            fullRoutputFilePath+"]\nafter executing the R script.\n";      
     if(dbugFlag)
       System.out.println("\nRE-RRWR.3 get Report/ fullRoutputFilePath='"+
                          fullRoutputFilePath+"'"+
                          "\n sR='"+sR+"'\n"); 
    
    /* [7] If no output report file was were specified, just return. */
    if(a.nOutputFiles==0)    
    {
      sR= "\nThe analysis did not generate any report";   
      setWaitCursor(false);
      return(sR);
    }
     
    /* [8] Copy reports in the Temp/ directory to Report/ directory if any */
    copyTempOutputFilesToReportDir();
     
    /* [9] Copy data for any R_SET_R2CLIENT__xxx entries in the RLO. It will
     * read R output files and convert them to client data structures and
     * save into the state of client.
     */
    setRoutput2ClientObjects();
       
    setWaitCursor(false);
    return(sR);
  } /* runRscriptWithR */
   
    
  /**
   * execRscript() - exec R with cmd to process the .R script.
   * Note: if S-Plus is to be used (and it exists on the system),
   * then useSPlusFlag is true. The fullRunRfilePath and remapped Rscript
   * will be set up to take this into account.
   *<P>
   * It uses a batch file to call R via the Rtermprogram. For S-Plus,
   * the batch file calls splus or sqpe program.
   *<P>
   * The results from R are save to a file in the Reports/R-OutputFile.txt
   * folder.
   * @return stdout response from evaling .R script by R, null if failed.
   */
  private String execRscript()
  { /* execRscript */
    int
      idxSpaceInRunFilePath= fullRunRfilePath.indexOf(" "),
      idxSpaceInRscriptInputPath= fullRscriptInputPath.indexOf(" "),
      idxSpaceInRscriptOutputPath= fullRoutputFilePath.indexOf(" ");  
    String 
      Rcmd,
      sRunQuote= (idxSpaceInRunFilePath==-1) ? "" : "\"",
      sInputQuote= (idxSpaceInRscriptInputPath==-1) ? "" : "\"",
      sOutputQuote= (idxSpaceInRscriptOutputPath==-1) ? "" : "\"",
      sResponse= "";
     
    /* [1] Create command to send to exec() with paths */ 
    if(isWindowsFlag)
    { /* do it for Windows */
      String windowsCmd= sRunQuote + fullRunRfilePath + sRunQuote +
                         " " + sInputQuote + fullRscriptInputPath + 
                         sInputQuote +
                         " " + sOutputQuote + fullRoutputFilePath +
                         sOutputQuote;      
      Rcmd= windowsCmd;
    }
    else
    { /* do it for Unix */
      /* NOTE: for Unix, we do a 'source' to avoid having to chmod 755 */     
      RLO a= rlo.getCurrentRLO(); 
      if(a.scriptSpecificRoptions==null)
        a.scriptSpecificRoptions= "";
      String
        baseRoptions,
        optionsR,
        unixCmd;  
      if(!useSPlusFlag)
      { /* generate for R */
        baseRoptions= ((a.processBits & rPB_useVanillaBit)!=0)
                         ? " --vanilla --no-restore-history --slave "
                         : " --no-restore-history --slave ";
        optionsR= baseRoptions + a.scriptSpecificRoptions;
        unixCmd= "R cmd BATCH " + optionsR +
                 fullRscriptInputPath+ " " + fullRoutputFilePath; 
      }
      else 
      { /* generate for SPlus */
        /* [TODO] fix up with additional switches and vars */
        String setProject= " S_PROJ=\""+tempBasePath+"\" S_DATA=\""+
                           tempBasePath+"\"";
        baseRoptions= ((a.processBits & rPB_useVanillaBit)!=0)
                         ? " /BATCH "
                         : " /BATCH ";
        optionsR= baseRoptions + a.scriptSpecificRoptions;
        unixCmd= "splus " /* "sqpe " */ + setProject + 
                 optionsR + fullRscriptInputPath+ " " + fullRoutputFilePath; 
      }
      Rcmd= unixCmd;
    } /* do it for Unix */
     
    if(dbugFlag)
      System.out.println("\nRE-ERS Rcmd ='"+Rcmd+"'\n"+
                         "  fullRunRfilePath ='"+fullRunRfilePath+"'\n"+
                         "  fullRscriptInputPath ='"+fullRscriptInputPath+
                         "'\n"+
                         "  fullRoutputFilePath ='"+fullRoutputFilePath);       
       
    /* [2] Execute the call as a separate process */
    Process p= null;
    try 
     { /* do the exec system call and get stdout&stderr output */
       p= Runtime.getRuntime().exec(Rcmd);
       
       try 
       { /* Get input stream from the process's output */
         InputStream is= p.getInputStream();     
         int c;
         if(dbugFlag)
           System.out.println(
                   "RE-ERS.2 reading output from exec'd R process.");
         
         /* Read the stdout and stderr data from the process */
         while((c= is.read()) != -1)
           sResponse += c;
        
         if(dbugFlag)
           System.out.println("RE-ERS.2.1 sResponse='"+sResponse);      
         
         try 
         { /* wait for the process to finish doing its thing */
           p.waitFor();
           is.close();           
         }
         catch(InterruptedException ie) 
         {
           if(dbugFlag)
             System.out.println("RE-ERS.2.2 - Error with waitFor(): "+ie);
           ie.printStackTrace();
         }
         
         if(dbugFlag)
           System.out.println("RE-ERS.2.3 - process exited with: " + 
                             p.exitValue());
         
         /* All done with the process, get rid of it */
         p.destroy();
       }/* Get input stream from the process's output */
       
       catch(Exception e2) 
       {         
         if(dbugFlag)
           System.out.println(
                   "RE-ERS.2.5 - Error reading stdout from process"+e2);
         e2.printStackTrace();
       }
     } /* do the exec system call and get stdout&stderr output */
     
     catch(Exception e) 
     {       
       if(dbugFlag)
         System.out.println("RE-ERS - Error with exec(rCmd); " + e);
       e.printStackTrace();
     }
     
    return(sResponse);
  } /* execRscript */
  
  
  /**
   * getCurDateStr() - return date string in the format of YYMMDDHHMMSS.
   * Note: Adds "0" to first single digit if value is 1-9.
   */
  private static String getCurDateStr()
  { /* getCurDateStr */
    
    GregorianCalendar cal= new GregorianCalendar();  /* setup date */
    int
      yy= cal.get(Calendar.YEAR)-2000,    /* year in 2 digit format */
      mm= cal.get(Calendar.MONTH)+1,      /* Month, note: add 1 since 0-11*/
      dd= cal.get(Calendar.DAY_OF_MONTH), /* day */
      hh= cal.get(Calendar.HOUR_OF_DAY),  /* hour */
      min= cal.get(Calendar.MINUTE),      /* minute */
      ss= cal.get(Calendar.SECOND);       /* seconds */
    String
      sY,                                 /* Year  ie "03" */
      sM,                                 /* Month ie "12" */
      sD,                                 /* Day ie "30" */
      sH,                                 /* Hour ie "01", */
      sMin,                               /* minutes ie "40" */
      sS;                                 /* Seconds ie "60" */ 
    
    sY= "0"+ (new Integer(yy)).toString();
    
    sM= (mm<10)
          ? "0"+ (new Integer(mm)).toString()
          : (new Integer(mm)).toString();
    
    sD= (dd<10)
          ? "0"+ (new Integer(dd)).toString()
          : (new Integer(dd)).toString();
    
    sH= (hh<10)
          ? "0"+ (new Integer(hh)).toString()
          : new Integer(hh).toString();
    
    sMin= (min<10)
            ? "0"+ (new Integer(min)).toString()
            : new Integer(min).toString();
    
    sS= (ss<10)
          ? "0"+ new Integer(ss).toString()
          : new Integer(ss).toString();
    
    String date= sY+sM+sD+sH+sMin+sS;
    
    return(date);
  } /* getCurDateStr */
  

  /**
   * copyTempOutputFilesToReportDir() - show plots generated if any with the
   * last R eval. If there were no plots generated with the last Eval, then
   * it is a no-op. Just say so in the msg area.
   *<P>
   * If the useRLOloggingFlag is set, then use RLO Report logging by 
   * creating subdirectory in {project}/Report/{RLOname}-yymmdd.hhmmss/ 
   * to store the RLO output files copied to Report/.
   * @see RLO#getCurrentRLO
   */
  private void copyTempOutputFilesToReportDir()
  { /* copyTempOutputFilesToReportDir */    
    String outputDataFileNames[]= getOutputDataFileNames(); /* cur. RLO */
    int 
      nOutputFiles= outputDataFileNames.length;
      
    if(nOutputFiles > 0)
    { /* find if there are any plot files to move */
      int outputDataTypes[]= getOutputDataTypes();
      
      String reportPath= reportBasePath;
      if(useRLOloggingFlag)   
        reportPath= reportBasePath+timeStampReportDir;             
      
      for(int j=0;j<nOutputFiles;j++)
      { /* look for the first report file name */
        if(outputDataTypes[j]==rOfileTypeStdOut)
          continue; /* DON'T COPY STDOUT since it is already in /Report*/
        String tmpFile= tempBasePath + outputDataFileNames[j];
        String rptFile= reportPath + outputDataFileNames[j];
        copyFile(tmpFile, rptFile, null,0);
        deleteLocalFile(tmpFile);        
      } /* look for the first report file name */
    } /* find if there are any plot files to move*/
        
  } /* copyTempOutputFilesToReportDir */
  
  
  /**
   * createTempRscript() - create a copy of the .R script in  <project>/Temp/
   * for the current RLO database analysis currently selected.
   * The .R script is always copied to the <project>/Temp/ and
   * a R command 
   *   "setwd(" + tempBasePath +")" 
   * and
   *   "library("+RLORlibr+",lib.loc=\"" + clientRlibrBasePath + "\")"
   * are prepended TO THE FRONT of the
   * contents of the .R script to tell R to set the working direfory here.    
   * The script name has a "tmp-" prefix to the original RscriptName.
   * We use the new .R script name in the fullRscriptInputPath.
   * @param RscriptName is the name of the script to use
   * @return null if ok, else contains error message
   */
  private String createTempRscript(String RscriptName)
  { /* createTempRscript */
    String
      sR= null,
      setwdStr= "",
      libraryStr= "";
    
    if(!useSPlusFlag)
    { /* Setup for R */
      setwdStr= "setwd(\"" + tempBasePath +"\") # set working directory\n";
      libraryStr= "library("+RLORlibr+",lib.loc=\"" +clientRlibrBasePath+
                  "\")\n"+
                  "library(modreg)\n";
    }
    else
    { /* setup for S-Plus */
      /* Note: we set the working directory with 
       * "S_PROJ=<tempBasePath>" in .bat file 
       */
      //setwdStr= "setwd(\"" + tempBasePath +"\") # set working directory\n";
      libraryStr= "assign(where=0,lib.loc,\""+clientRlibrBasePath+"\")\n"+
                  "library("+RLORlibr+")\n"+
                  "library(modreg)\n";
    }
    
    String sSetwdTemp= cvtBackslash2Fwdslash(setwdStr);      
   
    /* Copy the original .R script with setwd() prepended to the script.
     * The original .R scripts are kept in
     * {client installation}/R/ directory and are distributed
     * with the client distribution.
     */
    String
      sourceRscript= RscriptBasePath + RscriptName,
      origRscript=  readTextFromFile(sourceRscript,null),
      Rscript= sSetwdTemp + libraryStr + origRscript;
    fullRscriptInputPath= tempBasePath + "tmp-"+RscriptName;
    if(! writeTextToFile(fullRscriptInputPath, Rscript))
    { /* problem - could not create the Tmp copy of the .R script */
      sR= "Can't write out temporary .R script ["+fullRscriptInputPath+"]";
    }  
    
    if(dbugFlag)
      System.out.println("\nRE-CTRS .R fullRscriptInputPath='"+
                         fullRscriptInputPath+"'");      
    
    return(sR);
  } /* createTempRscript */
  
  
  /**
   * createRunRscript() - create startup script to run R that is OS specific
   * @return startup script
   * @see RLO#getCurrentRLO
   */
  private String createRunRscript()
  { /* createRunRscript */
    String
      fullRbinBasePath= (!useSPlusFlag)
                          ? (RbinBasePath +"Rterm")
                          : (SPlusBinBasePath +"splus");
    if(isWindowsFlag)
      fullRbinBasePath += ".exe";
    else
    { /* handling UNIX programs */
      if(!useSPlusFlag)
        fullRbinBasePath= RbinBasePath +"R term";
      else
        fullRbinBasePath= SPlusBinBasePath +"splus";
    }
    
    /* Use --vanilla as well as --slave 
     * Note: --vanilla is equivalent to 
     *  --no-save --no-restore --no-site-file -- no-init-file --no-environ
     *
     * Add other options such as required memory size, etc.
     */ 
    RLO a= rlo.getCurrentRLO();     
    if(a.scriptSpecificRoptions==null)
      a.scriptSpecificRoptions= "";
    String
      baseRoptions= ((a.processBits & rPB_useVanillaBit)!=0)
                       ? " --vanilla --no-restore-history --slave "
                       : " --no-restore-history --slave ";
     if(useSPlusFlag)
     { /* [TODO] Need to add equivalent of --vanilla for S-PLUS */
        baseRoptions= " /BATCH ";
     }
    String                   
      optionsR=  baseRoptions + a.scriptSpecificRoptions;
                       
    // [TODO] do we add ".bin" for any of the other OSs' ?
    
    /* If quoteRunPathFlag is set then add "\ ...\" around exec program
     *    "\"" + RbinBasePath + ("Rterm" or "splus") + "\"" before exec
     */
    if(quoteRunPathFlag)
      fullRbinBasePath = "\"" + fullRbinBasePath +  "\"";      
    
    /* Build the OS script to start Rterm or splus. */
    String
      runRscript= fullRbinBasePath + optionsR + " < %1 > %2";
        
    if(dbugFlag)
      System.out.println("\nRE-CRR runRscript='"+runRscript);
    
    return(runRscript);
  } /* createRunRscript */ 
  
  
  /**
   * getNbrAnalyses() - get the number of analyses in the RLO DB
   * @return # of analyses in the RLO DB
   */
  int getNbrAnalyses()
  { return(nAnalyses); }
  
  
  /**
   * getListofRLOscriptNames() - get list of all R script names
   * @return list of RLO Rscript names
   */
  String[] getListofRLOscriptNames()
  { return(rlo.getListofRLOscriptNames()); }
     
   
  /**
   * getListofRLOmenuNames() - get list of all menuNames
   * @return list of RLO menu names
   */
  String[] getListofRLOmenuNames()
  { return(rlo.getListofRLOmenuNames()); }
  
  
  /**
   * newRLO() - create new empty R LayOut (RLO) instance to the RLO database.
   * @return the id number
   */
  int newRLO()
  { return(rlo.newRLO()); }
  
  
  /**
   * addRLO() - add new R LayOut (RLO) instance to the RLO database.
   * The RLO is a meta-language for specifying the processing interaction
   * between R and client.
   *<P>
   * E.g., the following is an example that exports various types (4) of
   * client data, generates 4 types of output files, and sets the
   * client state from 2 of those files.
   *<P>
   * [TODO] redo documentation ...
   *<PRE>
   * String inFiles[]= { "R-InputFile-XY-classNames.txt",
   *                     "R-InputFile-X-sample-names.txt",
   *                     "R-InputFile-Y-sample-names.txt",
   *                     "R-InputFile-XY-sets-expr.txt" };
   * int inTypes[]= { R_DATA_TYPE_XY_CLASSNAMES,
   *                  R_DATA_TYPE_HP_X_SET_SAMPLENAMES,
   *                  R_DATA_TYPE_HP_Y_SET_SAMPLENAMES,
   *                  R_DATA_TYPE_HP_XY_SETS };
   * int processBits= (R_PB_USE_FILTER | R_PB_SAMPLES_HDR);
   * int genRbits= (R_GENR_HIST | R_GENR_LOWESS | R_GENR_PLOT);    
   * String outFiles[]= { "R-Stdout.txt", "R-OutputFile.pdf", 
   *                      "R-GeneSet.txt", "R-ConditionList.txt",
   *                      "R-LowessTbl.txt"};
   * int outTypes[]= { R_FILE_TYPE_STDOUT, R_FILE_TYPE_PDF,
   *                   R_FILE_TYPE_TAB_DELIM_TBL, R_FILE_TYPE_TAB_DELIM_TBL,
   *                   R_FILE_TYPE_TAB_DELIM_TBL}; 
   * String setR2ClientFiles[]= { "R-GeneSet.txt", "R-ConditionList.txt" };
   * String setR2ClientObjs[]= { "Clustered-Genes", "Similar-Samples" };
   * int setR2ClientType[]= { R_SET_R2CLIENT__GENE_SET, 
   *                          R_SET_R2CLIENT__CONDITION_LIST };
   * String scriptSpecificRoptions= "--vsize=20M";
   *
   *  addRLO( "Analyze HP-XY 'set' expression data", "Plugins:RLOmethods",
   *          "ClientAnalyzeXYsets.R",
   *          inFiles, inTypes, 
   *          processBits, genRbits,
   *          outFiles, outTypes,
   *          setR2ClientFiles, setR2ClientObjs, setR2ClientType,
   *          scriptSpecificRoptions );
   *</PRE>
   * @param menuName text description of the RLO entry
   * @param menuStubName used by client to put RLO menu entry in a
   *        particular menu.
   * @param RscriptName is the name of the .R file
   * @param inputDataFileNames opt. list of R input data file names
   * @param inputDataTypes corresponding list of R input data file types
   * @param processBits set used during eval
   * @param genRbits set used during edit by R script GUI (0 if none)
   * @param outputDataFileNames opt. list of R output data file names
   * @param outputDataTypes corresponding list of R output data file types
   * @param setR2ClientFileNames opt. list of file names to set R output
   *        data to client state objects
   * @param setR2ClientObjNames opt. list of client object names to
   *        set R output data to client state objects
   * @param setR2ClientObjType opt. list of client object types
   *        to set R output data to client state objects
   * @param scriptSpecificRoptions
   * @return the id number
   */
  int addRLO(String menuName, String menuStubName, String RscriptName, 
             String inputDataFileNames[], int inputDataTypes[],
             int processBits, int genRbits,
             String outputDataFileNames[], int outputDataTypes[],
             String setR2ClientFileNames[], String setR2ClientObjNames[], 
             int setR2ClientObjTypes[],               
             String scriptSpecificRoptions )
  { /* addRLO */
    return(rlo.addRLO(menuName, menuStubName, RscriptName, 
           inputDataFileNames, inputDataTypes,
           processBits, genRbits,
           outputDataFileNames, outputDataTypes,
           setR2ClientFileNames, setR2ClientObjNames, setR2ClientObjTypes,               
           scriptSpecificRoptions)
           );
  } /* addRLO */
  
  
  /**
   * setRLO() - set R LayOut (RLO) instance to the RLO database.
   * The RLO is a meta-language for specifying the processing interaction
   * between R and client.
   *<P>
   * E.g., the following is an example that exports various types (4) of
   * client data, generates 4 types of output files, and sets the
   * client state from 2 of those files.
   *<P>
   * [TODO] redo documentation ...
   *<PRE>
   * int rloID= 10;
   * String inFiles[]= { "R-InputFile-XY-classNames.txt",
   *                     "R-InputFile-X-sample-names.txt",
   *                     "R-InputFile-Y-sample-names.txt",
   *                     "R-InputFile-XY-sets-expr.txt" };
   * int inTypes[]= { R_DATA_TYPE_XY_CLASSNAMES,
   *                  R_DATA_TYPE_HP_X_SET_SAMPLENAMES,
   *                  R_DATA_TYPE_HP_Y_SET_SAMPLENAMES,
   *                  R_DATA_TYPE_HP_XY_SETS };
   * int processBits= (R_PB_USE_FILTER | R_PB_SAMPLES_HDR);
   * int genRbits= (R_GENR_HIST | R_GENR_LOWESS | R_GENR_PLOT);
   * String outFiles[]= { "R-Stdout.txt", "R-OutputFile.pdf",
   *                      "R-GeneSet.txt", "R-ConditionList.txt",
   *                      "R-LowessTbl.txt"};
   * int outTypes[]= { R_FILE_TYPE_STDOUT, R_FILE_TYPE_PDF,
   *                   R_FILE_TYPE_TAB_DELIM_TBL, R_FILE_TYPE_TAB_DELIM_TBL,
   *                   R_FILE_TYPE_TAB_DELIM_TBL};
   * String setR2ClientFiles[]= { "R-GeneSet.txt", "R-ConditionList.txt" };
   * String setR2ClientObjs[]= { "Clustered-Genes", "Similar-Samples" };
   * int setR2ClientType[]= { R_SET_R2CLIENT__GENE_SET,
   *                          R_SET_R2CLIENT__CONDITION_LIST };
   * String scriptSpecificRoptions= "--vsize=20M";
   *
   *   setRLO(rloID,
   *          "Analyze HP-XY 'set' expression data", "Plugins:RLOmethods",
   *          "ClientAnalyzeXYsets.R",
   *          inFiles, inTypes,
   *          processBits, genRbits,
   *          outFiles, outTypes,
   *          setR2ClientFiles, setR2ClientObjs, setR2ClientType,
   *          scriptSpecificRoptions );
   *</PRE>
   * @param rloID is the RLO to assign new data
   * @param menuName text description of the RLO entry
   * @param menuStubName used by client to put RLO menu entry in a
   *        particular menu.
   * @param RscriptName is the name of the .R file
   * @param inputDataFileNames opt. list of R input data file names
   * @param inputDataTypes corresponding list of R input data file types
   * @param processBits set used during eval
   * @param genRbits set used during edit by R script GUI (0 if none)
   * @param outputDataFileNames opt. list of R output data file names
   * @param outputDataTypes corresponding list of R output data file types
   * @param setR2ClientFileNames opt. list of file names to set R output
   *        data to client state objects
   * @param setR2ClientObjNames opt. list of client object names to
   *        set R output data to client state objects
   * @param setR2ClientObjType opt. list of client object types
   *        to set R output data to client state objects
   * @param scriptSpecificRoptions
   * @return true if succeed
   */
  boolean setRLO(int rloID,
                 String menuName, String menuStubName, String RscriptName,
                 String inputDataFileNames[], int inputDataTypes[],
                 int processBits, int genRbits,
                 String outputDataFileNames[], int outputDataTypes[],
                 String setR2ClientFileNames[],
                 String setR2ClientObjNames[], int setR2ClientObjTypes[],
                 String scriptSpecificRoptions
                 )
  { /* setRLO */
    return(rlo.setRLO(rloID, menuName, menuStubName, RscriptName, 
                      inputDataFileNames, inputDataTypes,
                      processBits, genRbits,
                      outputDataFileNames, outputDataTypes,
                      setR2ClientFileNames, setR2ClientObjNames,
                      setR2ClientObjTypes,
                      scriptSpecificRoptions) );
  } /* setRLO */
  
  
  /**
   * rmvRLO() - remove the RLO from the analyses database
   * @param rloIdToRemove to remove
   * @return true if removed
   */
  public final boolean rmvRLO(int rloIdToRemove)   
  { /* rmvRLO */ 
      
      for(int i=0;i<nAnalyses;i++)
        if(analyses[i].id==rloIdToRemove)
        { /* remove from the list */
          
          /* [1] Found it - go Remove RLO/<>.rlo and /R/<>.R files */      
          try
          { /* Remove RLO/<>.rlo and /R/<>.R files */
            String
              rsFile= analyses[i].RscriptName,
              rloFile= rsFile.substring(0,rsFile.length()-2)+".rlo",
              fullRscriptFile= RscriptBasePath + rsFile,
              fullRloFile= RLObasePath + rloFile;
            
            /* [1.1] Ask user if this is the one they want to delete. */
            String
              areYouSure= popupDialog("[yes|no]. Delete "+rsFile+" and "+
                                      rloFile +" files? Are you sure? ",
                                      "no"); 
            if(!areYouSure.equalsIgnoreCase("yes"))
              return(false);               /* don't bother */
            
            /* [1.2] Delete R script */
            File fR= new File(fullRscriptFile);
            fR.delete();
            
            /* [1.3] Delete RLO file */
            File fRLO= new File(fullRloFile);
            fRLO.delete();
            
            /* [1.4] Remove from menu, shift list down by 1 from [i] to 
             * [nAnalyses-1]
             */
            for(int x=i; x<nAnalyses; x++) 
              analyses[x]= analyses[x+1];
            
            nAnalyses--;  /* since deleted, decrease by 1 */
            
            /* [1.5] Remove last object from the list by setting to null */  
            analyses[nAnalyses]= null;
            return(true);
            
          } /* Remove RLO/<>.rlo and /R/<>.R files */
          catch(Exception e)
          { 
            System.out.println(
                            "rmvRLO(): Error with deleting RLO file # "+ i);
            return(false);
          }
            
        }/* remove from the list */
      
      return(false);  /* not found/error */
    } /* rmvRLO */
  
  
  /**
   * clearRLOdb() - clear list of R LayOuts analyses in the database
   */
  public final void clearRLOdb()
  { /* clearRLOdb */
    rlo.clearRLOdb();
  } /* clearRLOdb */
  
  
  /**
   * getRLOidByRscriptName() - get the current RLO analysis method id 
   * by RscriptName
   * @param RscriptName to lookup in the database
   * @return current RLO object id, -1 if not found
   */
  public final int getRLOidByRscriptName(String RscriptName)
  {  return(rlo.getRLOidByRscriptName(RscriptName)); }
    
  
  /**
   * getCurrentRLO() - get the current RLO analysis method object
   * @return current RLO object
   */
  RLO getCurrentRLO()
  { return(rlo.getCurrentRLO()); }
  
  
  /**
   * setCurrentRLO() - set the current RLO analysis method by id
   * @param analysisNbr to set as the current analysis method
   */
  void setCurrentRLO(int analysisNbr)
  { rlo.setCurrentRLO(analysisNbr); }
  
  
  /**
   * getInputDataFileNames() - get current RLO list of input data file names
   * @return current RLO list of output data file names
   */
  String[] getInputDataFileNames()
  { return(rlo.getCurrentRLO().inputDataFileNames); }
  
  
  /**
   * getInputDataTypes() - get current RLO list of input data file types
   * @return current RLO list of input data file types
   */
  int[] getInputDataTypes()
  { return(rlo.getCurrentRLO().inputDataTypes); }
  
  
  /**
   * getOutputDataFileNames() - get current RLO list of output data file
   * names.
   * @return current RLO list of output data file names
   */
  String[] getOutputDataFileNames()
  { return(rlo.getCurrentRLO().outputDataFileNames); }
  
  
  /**
   * getOutputDataTypes() - get current RLO list of output data file types
   * @return current RLO list of output data file types
   */
  int[] getOutputDataTypes()
  { return(rlo.getCurrentRLO().outputDataTypes); }
  
  
  /**
   * getSetR2ClientFileNames() - get current RLO list of R2Client data file
   * names.
   * Note the data file is also specified in the output file names.
   * @return current RLO list of R2Client data file names
   */
  String[] getSetR2ClientFileNames()
  { return(rlo.getCurrentRLO().setR2ClientFileNames); }
  
  
  /**
   * getSetR2ClientObjNames() - get current RLO list of R2Client object
   * names
   * @return current RLO list of R2Client  object names
   */
  String[] getSetR2ClientObjNames()
  { return(rlo.getCurrentRLO().setR2ClientObjNames); }
  
  
  /**
   * getSetR2ClientObjTypes() - get current RLO list of R2Client object
   * types
   * @return current RLO list of R2Client object types
   */
  int[] getSetR2ClientObjTypes()
  { return(rlo.getCurrentRLO().setR2ClientObjTypes); }
  
  
  /**
   * cvRLO2string() - create string representing the R LayOut (RLO) 
   * of the instance
   * @param rloID is the index of the RLO to convert
   * @param optProcessBitsStr optional ProcessBits string if computed
   *        elsewhere...
   * @param optGenRbitsStr optional genRbits representation computed 
   *        elsewhere.
   * @return string representing the RLO
   */
  String cvRLO2string(int rloID, String optProcessBitsStr, 
                      String optGenRbitsStr)
  {  return(toString(rloID, optProcessBitsStr, optGenRbitsStr)); }
      
 
  /**
   * setInputFilesData() - set current RLO list of input data 
   * (fileName,dataType)
   * @param fileNames - list of input files names
   * @param dataTypes - list of input files data types
   * @return true if succeed
   */
  public final boolean setInputFilesData(String fileNames[],
                                         int dataTypes[])
  { /* setInputFilesData */
    RLO a= getCurrentRLO();
    a.inputDataFileNames= fileNames;
    a.inputDataTypes= dataTypes;
    a.nInputFiles= (fileNames==null) ? 0 : fileNames.length;
    return(true);
  } /* setInputFilesData */
  
  
  /**
   * setOutputFilesData() - set current RLO list of output data 
   * (fileName,dataType)
   * @param fileNames - list of input files names
   * @param dataTypes - list of input files data types
   * @return true if succeed
   */
  public final boolean setOutputFilesData(String fileNames[],
                                          int dataTypes[])
  { /* setOutputFilesData */
    RLO a= getCurrentRLO();
    a.outputDataFileNames= fileNames;
    a.outputDataTypes= dataTypes;
    a.nOutputFiles= (fileNames==null) ? 0 : fileNames.length;
    return(true);
  } /* setOutputFilesData */
    
  
  /**
   * setR2ClientFilesData() - set cur. RLO list of R2Client (file,obj,type)
   * data.
   * @param fileNames - list of R2Client file names
   * @param objNames - list of R2Client object names
   * @param objTypes - list of R2Client object types
   * @return true if succeed
   */
  public final boolean setR2ClientFilesData(String fileNames[],
                                            String objNames[],
                                            int objTypes[] )
  { /* setR2ClientFilesData */
    RLO a= getCurrentRLO();
    a.setR2ClientFileNames= fileNames;
    a.setR2ClientObjNames= objNames;
    a.setR2ClientObjTypes= objTypes;
    a.nSetR2ClientFiles= (fileNames==null) ? 0 : fileNames.length;
    return(true);
  } /* setR2ClientFilesData */
  

 /*
  * getAllProcessBits() - get Process Bits using R_PB_xxxx bits for
  * current RLO.
  * @return RLO process bits
  */
  public final int getAllProcessBits()
  { return(getCurrentRLO().processBits); }
  
  
 /**
  * setAllProcessBits() - set Process Bits using R_PB_xxxx bits for 
  * current RLO.
  * @param bits to use in set in RLO process bits pattern
  */
  public final void setAllProcessBits(int bits)
  { getCurrentRLO().processBits= bits; }
  
  
  /**
   * toString() - create string representing the R LayOut (RLO) of 
   * the RLO instance
   * @param rloID is the index of the RLO to convert
   * @param optProcessBitsStr optional ProcessBits string if 
   *        computed elsewhere...
   * @param optGenRbitsStr optional genRbits string if computed elsewhere...
   * @return string representing the RLO
   */
  String toString(int rloID, String optProcessBitsStr, String optGenRbitsStr)
  { /* toString */
    if(analyses==null || rloID<0 || rloID>= nAnalyses)
      return("Illegal RLO id ["+rloID+"}");
          
    RLO rlo= analyses[rloID];     
    String sR= "R LayOut #"+ rlo.id+"\n";
     
    sR += "Menu name: '"+rlo.menuName+"'\n";
    sR += "Submenu to place Menu entry in for client: '"+rlo.menuStubName+
          "'\n";
    sR += ".R script name: '"+rlo.RscriptName+"\n";  
    sR += "RLO creation date: '"+rlo.date+"\n"; 
     
    sR += "# of input data files: "+rlo.nInputFiles+"\n";
    if(rlo.nInputFiles>0)
    { /* input files exist */
      for(int i=0;i<rlo.nInputFiles;i++)
      {
        sR += "  Input data file["+(i+1)+"]: '"+rlo.inputDataFileNames[i]+
              "'\n";
        sR += "  Input data type["+(i+1)+"]: '"+
              cvtInputType2Str(rlo.inputDataTypes[i])+"'\n";
      }
    } /* input files exist */
     
    /* list the processBits */
    if(optProcessBitsStr!=null)
      sR += optProcessBitsStr;
    else
    { /* use generic ProcessBits */
      sR += "Process "+clientName+
            " data when export it to R (R input files)\n";
      for(int i=0;i<nProcessBits;i++)
      { /* report all process bits */
        String sPrefix= ((rlo.processBits & rProcessBitVal[i])==0)
                            ? "Don't use " : "Use ";
        sR += sPrefix + rProcessBitName[i];
      }
    } /* use generic ProcessBits */
                
    /* list the genRBits only for demo RLOs */
    if(optGenRbitsStr!=null)
      sR += optGenRbitsStr;
         
    /* Summarize output files */
    sR += "# of output data files: "+rlo.nOutputFiles+"\n";
    if(rlo.nOutputFiles>0)
    { /* output files exist */
      for(int i=0;i<rlo.nOutputFiles;i++)
      {
        sR += "  Output data file["+(i+1)+"]: '"+rlo.outputDataFileNames[i]+
              "'\n";
        sR += "  Output data type["+(i+1)+"]: '"+
              cvtOutType2Str(rlo.outputDataTypes[i])+"'\n";
      }
    }
          
    /* Summarize R2Client files */
    sR += "# of "+r2ClientPrefix+" action: "+rlo.nSetR2ClientFiles+"\n";
    if(rlo.nSetR2ClientFiles>0)
    { /* R2Client files exist */
      for(int i=0;i<rlo.nSetR2ClientFiles;i++)
      {
        sR += "  "+r2ClientPrefix+" data file["+(i+1)+"]: '"+
              rlo.setR2ClientFileNames[i]+"\n";
        sR += "  "+r2ClientPrefix+" object name["+(i+1)+"]: '"+
              rlo.setR2ClientObjNames[i]+"'\n";
        sR += "  "+r2ClientPrefix+" object action["+(i+1)+"]: '"+
              cvtR2ClientType2Str(rlo.setR2ClientObjTypes[i])+"'\n";
      }
    } /* R2Client files exist */
          
    sR += "scriptSpecificRoptions: '"+rlo.scriptSpecificRoptions+"'\n";
     
    return(sR);
  } /* toString */
   
   
  /**
   * writePermanentRLOdatabase() - write RLO entries to the permanent
   * <client installation>/RLO/ database. 
   * Note: it does NOT write demo databases with the genRbit R_GENR_DEMO set.
   * @return true if succeed
   */
  boolean writePermanentRLOdatabase()
  { /* writePermanentRLOdatabase */ 
    File fRLO= new File(RLObasePath);
    if(! fRLO.isDirectory())
     return(false);                      /* can't find "RLO/" directory */
    
    int oldCurRLOid= curAnalysis;        /* save the current RLO */ 
    RLO rloI;
    
    for(int i=0;i<nAnalyses;i++)
    { /* write out all non-demo RLOs */
      rloI= analyses[i];
      if(rloI.genRbits!=0)
        continue;                        /* Don't write out the demo RLOs */
      /* Write RLO by .rlo file name for the specified RLO (rloID).
       * The file resides in {Client installation}/RLO/{rScriptName}.rlo
       * file.
       */
      boolean ok= writeRLOfile(RLObasePath, i);
    } /* write out all non-demo RLOs */
    
    setCurrentRLO(oldCurRLOid);         /* Restore the current RLO */ 
     
    return(false);
  } /* writePermanentRLOdatabase */
  
  
  /**
   * readPermanentRLOdatabase() - read RLO entries from the permanent
   * <client installation>/RLO/*.rlo file database.
   * @param loadDemoRLOsFlag to read demo .rlo databases, else they are 
   *        ignored.
   * @return true if succeed
   */
  boolean readPermanentRLOdatabase(boolean loadDemoRLOsFlag)
  { /* readPermanentRLOdatabase */    
    int
      oldCurRLOid= curAnalysis,  /* save the current RLO */ 
      nRLOfiles= 0;     
    String rloNames[]= null;
    
    /* Get a list of .rlo files */
    try
    { /* get the directory list of names */
      File f= new File(RLObasePath);
      if(f.isDirectory() && f.canRead())
      {        
        rloNames= f.list();
        nRLOfiles= rloNames.length;
      }
    }
    catch(Exception e)
    { /* problem - abort save */
    }
    
    /* return if no data */
    if(nRLOfiles==0)
      return(false);
    
    /* Read .rlo files and ignore any with DEMO scripts if not allowed */
    for(int i=0;i<nRLOfiles;i++)
    { /* only read in .rlo files */
      if(!loadDemoRLOsFlag && rloNames[i].startsWith("DemoRscript"))
        continue;     /* ignore DEMO  RLOs */
      
      String rloFile= RLObasePath+rloNames[i];
       
      /* Read RLO by .rlo file name into a new RLO (rloID).
       * The file resides in {Client installation}/RLO/*.rlo file 
       */
      readRLOfile(rloFile, loadDemoRLOsFlag);
    }
    
    setCurrentRLO(oldCurRLOid);    /* Restore the current RLO */  
   
    return(true);
  } /* readPermanentRLOdatabase */ 
  
  
  /**
   * rmvRtnChars() - remove return chars. Map '\r' or "\r\n" to '\n' chars.
   * @param String str to process
   * @return String with '\r' removed.
   */
  private static String rmvRtnChars(String str)
  { /* rmvRtnChars */    
    if(str==null)
      return(null);
    
    String sR= "";
    int
      oldSize= str.length(),
      oldSizeM1= oldSize-1,
      newSize= 0,
      iLA,
      j= 0;
    char
      ch, 
      chLA;
    
    for(int i= 0; i<oldSize; i++)
    { /* process the string */
      iLA= i+1;
      ch= str.charAt(i);
      
      if(ch=='\r')
      { /* Check look ahead to map \r to \n */
        chLA= (iLA<oldSizeM1) ? str.charAt(iLA) : '\0';
        if(chLA=='\n')
          continue;   /* ignore the \r if part of \r\n pair */
        else
          ch= '\n';   /* map the \r terminator to \n terminator */
      } /* Check look ahead to map \r to \n */
      
      /* Build new string */
      sR += ch;
      newSize++;
    } /* process the string */
    
    return(sR);
  } /* rmvRtnChars */
  
  
  /**
   * getNextStrNameValFromLine() - get next line and parse 'name=value\n'.
   * Return false if EOF. If fail, return null.
   * The (parseName, parseValue, parseDelimChar) is saved
   * in the global instance.
   * @param parser is the string tokenizer
   * @return true succeed
   */
  private boolean getNextStrNameValFromLine(StringTokenizer parser)
  { /* getNextStrNameValFromLine */    
    try
    { /* parse it into (name,value) pairs) */
      parseName= parser.nextToken("=");
      if(parseName==null || parseName.length()==0)
        return(false);          /* no more data */
      int chName= (int)parseName.charAt(0);
      
      if(chName=='\r' || chName=='\n')
        parseName= parseName.substring(1);
      if(parseName.length()==0)
        return(false);          /* no more data */
      
      if(!parser.hasMoreTokens())
        return(false);
      parseValue= parser.nextToken("\n");
      parseDelimChar= (int)parseValue.charAt(0);
      parseValue= (parseDelimChar!='=') 
                    ? parseValue : parseValue.substring(1);
      return(true);
    } /* parse it into (name,value) pairs) */
    catch(Exception e)
    {
      return(false);
    }
  } /* getNextStrNameValFromLine */
  
  
  /**
   * getStrValFromLine() - get line and parse value for key 'name=value\n'.
   * If parser is not null, get data from parser else use global values
   * for next (parseName,parseValue) data.
   * The (parseName, parseValue, parseDelimChar) is saved in the
   * global instance so it can be reparsed if need be.
   * @param key is the key to use
   * @param parser is the string tokenizer
   * @return parseValue. If fail, return null.
   * @see #getNextStrNameValFromLine
   */
  private String getStrValFromLine(String key, StringTokenizer parser)
  { /* getStrValFromLine */
    if(parser!=null && !getNextStrNameValFromLine(parser))
      return(null);    
    else if(parseName==null || !parseName.equals(key))
     return(null);
    else
      return(parseValue);
  } /* getStrValFromLine */
  
  
  /**
   * cvs2i() - convert String to int with default value
   * @param str to convert
   * @param defaultValue if bad numeric string
   * @return numeric value
   */
  private static int cvs2i(String str, int defaultValue)
  { /* cvs2i */
    int i;
    try
    {
      i= java.lang.Integer.parseInt(str);
    }
    catch(NumberFormatException e)
    {i= defaultValue;}
    return(i);
  } /* cvs2i */
    
    
  /**
   * readRLOfile() - read RLO by .rlo file name into a new RLO (rloID).
   * The file resides in {MAEsplorer installation}/RLO/*.rlo file 
   * @param rloFileName full path file name for .rlo file
   * @param allowDemoLoadFlag to allow loading DEMO .rlo files
   * @return the new RLO id generated by doing an addRLO(), else -1 if failed
   * @see #getNextStrNameValFromLine
   * @see #getStrValFromLine
   */
  int readRLOfile(String rloFileName, boolean allowDemoLoadFlag)
  { /* readRLOfile */
    if(rloFileName==null && rloFileName.length()==0)
      return(-1);
    
    String fullPath= rloFileName;
    
    /* Read .rlo data file */
    String
      rloData= readTextFromFile(fullPath,"Loading state["+rloFileName+"]");
    if(rloData==null)
    {
      showMsg("Can't load RLO file ["+rloFileName+"]");
      return(-1);
    }
    /* Remove '\r' and map \r\n to \n */
    rloData= rmvRtnChars(rloData); 
    
    int idx1= rloFileName.lastIndexOf(fileSeparator);
    String
      rloFN= rloFileName.substring(idx1+1),
      testRscriptName= rloFN.substring(0,rloFN.length()-4)+".R";
    int 
      fileRloID= -1,                    /* list number */
      rloID= rlo.getRLOidByRscriptName(testRscriptName);
    if(rloID==-1)
      rloID= newRLO();                  /* make a new one */
    RLO rlo= analyses[rloID];
     
    StringTokenizer parser= new StringTokenizer(rloData, "=\n", false);
    
    String
      rloVersion= "",
      sVal;            
    
    /* Get next line & parse 'name=value\n'
     * Return false if EOF. If fail, return null.
     * The (parseName, parseValue, parseDelimChar) is saved
     * in the global instance.
     */
    Hashtable ht= new Hashtable(200);
    
    while(parser.hasMoreTokens()) 
    { /* build hash table ht of all (name,value) pairs */
      if(!getNextStrNameValFromLine(parser))
        break;
      if(parseValue==null)
        parseValue= "";
      ht.put(parseName,parseValue);
    } /* build hash table ht of all (name,value) pairs */
    
    /* Get parameters which may be out of order in the file. */
    parseName= "";                         /* start it off */   
    
    if((sVal= (String)ht.get("RLO_VERSION"))!=null)
      rloVersion= sVal;
    else
      return(-1);
    if((sVal= (String)ht.get("rloID"))!=null)
      fileRloID= cvs2i(sVal,-1);
    else
      return(-1);
    if((sVal= (String)ht.get("menuName"))!=null)
      rlo.menuName= sVal;
    else
      return(-1);
    if((sVal= (String)ht.get("RscriptName"))!=null)
      rlo.RscriptName= sVal;
    else
      return(-1);
    if((sVal= (String)ht.get("EditDate"))!=null)
      rlo.date= sVal;
    else
      return(-1);
    if((sVal= (String)ht.get("processBits"))!=null)
      rlo.processBits= cvs2i(sVal,0);
    else
      return(-1);
    if((sVal= (String)ht.get("genRbits"))!=null)
      rlo.genRbits= cvs2i(sVal,0);
    else
      return(-1);
    if((sVal= (String)ht.get("nInputFiles"))!=null)
      rlo.nInputFiles= cvs2i(sVal,0);
    else
      return(-1);
    if((sVal= (String)ht.get("nOutputFiles"))!=null)
      rlo.nOutputFiles= cvs2i(sVal,0);
    else
      return(-1);
    if((sVal= (String)ht.get("nSetR2ClientFiles"))!=null ||
       (sVal= (String)ht.get("nSetR2MaeFiles"))!=null)
      rlo.nSetR2ClientFiles= cvs2i(sVal,0);
    else
      return(-1);
    if((sVal= (String)ht.get("scriptSpecificRoptions"))!=null)
      rlo.scriptSpecificRoptions= sVal;
    else 
      return(-1);
    
    /* if DEMO bit set, then delete new RLO and return false */
    if(!allowDemoLoadFlag && (rlo.genRbits!=0))
    {
      rmvRLO(rloID);
      return(-1);
    }
    
    /* Validate version number - ignore data if not equal to 
     * current CBS_VERSION
     */
    if(rloVersion!=null && !rloVersion.equals(RLO_VERSION))
      return(-1);       /* can't read data from older version */
        
    /* allocate storage */
    if(rlo.nInputFiles!=0)
      rlo.inputDataFileNames= new String[rlo.nInputFiles];
    if(rlo.nInputFiles!=0)
      rlo.inputDataTypes= new int[rlo.nInputFiles];
    
    if(rlo.nOutputFiles!=0)
      rlo.outputDataFileNames= new String[rlo.nOutputFiles];
    if(rlo.nOutputFiles!=0)
      rlo.outputDataTypes= new int[rlo.nOutputFiles];
    
    if(rlo.nSetR2ClientFiles!=0)
      rlo.setR2ClientFileNames= new String[rlo.nSetR2ClientFiles];
    if(rlo.nSetR2ClientFiles!=0) 
      rlo.setR2ClientObjNames= new String[rlo.nSetR2ClientFiles];
    if(rlo.nSetR2ClientFiles!=0)
      rlo.setR2ClientObjTypes= new int[rlo.nSetR2ClientFiles];    
    
    for(int i=0;i<rlo.nInputFiles;i++)
    { /* Get input files */
     rlo.inputDataFileNames[i]= (String)ht.get(("rloInputFile-"+i));
     rlo.inputDataTypes[i]= cvs2i((String)ht.get(("rloInputType-"+i)), 0);
    }
                             
    for(int i=0;i<rlo.nOutputFiles;i++)
    { /* Get output files */
     rlo.outputDataFileNames[i]= (String)ht.get(("rloOutputFile-"+i));
     rlo.outputDataTypes[i]= cvs2i((String)ht.get(("rloOutputType-"+i)),0);
    }
                             
    for(int i=0;i<rlo.nSetR2ClientFiles;i++)
    { /* Get R2Client action files */
     rlo.setR2ClientFileNames[i]= (String)ht.get(("rloR2ClientFile-"+i));
     rlo.setR2ClientObjNames[i]= (String)ht.get(("rloR2ClientObj-"+i));
     rlo.setR2ClientObjTypes[i]=
                           cvs2i((String)ht.get(("rloR2ClientType-"+i)),0);
    }
    
    return(rloID);
  } /* readRLOfile */
 
  
  /**
   * writeRLOfile() - write RLO by .rlo file name for specified RLO (rloID).
   * The file resides in {Client installation}/RLO/{rScriptName}.rlo file 
   * @param rloBasePath is the base path of the RLO/ directory
   * @param rloID to save as .rlo file
   * @return true if succeed
   * @see FileIO#writeData
   * @see Util#cvtSpacesToUnderscores
   * @see Util#showMsg
   */
  boolean writeRLOfile(String rloBasePath, int rloID)
  { /* writeRLOfile */
    if(rloID<0 || rloID>=nAnalyses)
      return(false);
    
    RLO rlo= analyses[rloID];
    int lth= rlo.RscriptName.length();
    /* replace the ".R" with ".rlo" extension */
    String rloFileName= rlo.RscriptName.substring(0,lth-2) + ".rlo";
         
    String fullPath= rloBasePath + rloFileName;
    
    String hdr= "RLO_VERSION=" + RLO_VERSION + "\n" +
                "rloID=" + (""+rlo.id) + "\n" +
                "menuName=" + rlo.menuName + "\n" +
                "RscriptName=" + rlo.RscriptName + "\n" +
                "EditDate=" + rlo.date + "\n" +
                "processBits=" + (""+rlo.processBits) + "\n" +
                "genRbits=" + (""+rlo.genRbits) + "\n" +
                "nInputFiles=" + (""+rlo.nInputFiles) + "\n" +
                "nOutputFiles=" + (""+rlo.nOutputFiles) + "\n" +
                "nSetR2ClientFiles=" + (""+rlo.nSetR2ClientFiles) + "\n" +
                "scriptSpecificRoptions=" + 
                          ((rlo.scriptSpecificRoptions!=null)
                              ? rlo.scriptSpecificRoptions : "")+ "\n";
    
    StringBuffer sBuf= new StringBuffer(10000);  /* est. - optimize */
    sBuf.append(hdr);
   
   for(int i=0;i<rlo.nInputFiles;i++)
    { /* Get input files */
     sBuf.append("rloInputFile-"+i+"=");
     sBuf.append(rlo.inputDataFileNames[i]+"\n");
     
     sBuf.append("rloInputType-"+i+"=");
     sBuf.append(rlo.inputDataTypes[i]+"\n");
    }
                             
    for(int i=0;i<rlo.nOutputFiles;i++)
    { /* Get output files */
     sBuf.append("rloOutputFile-"+i+"=");
     sBuf.append(rlo.outputDataFileNames[i]+"\n");
     
     sBuf.append("rloOutputType-"+i+"=");
     sBuf.append(rlo.outputDataTypes[i]+"\n");
    }
                             
    for(int i=0;i<rlo.nSetR2ClientFiles;i++)
    { /* Get R2Client action files */
     sBuf.append("rloR2ClientFile-"+i+"=");
     sBuf.append(rlo.setR2ClientFileNames[i]+"\n");
     
     sBuf.append("rloR2ClientObj-"+i+"=");
     sBuf.append(rlo.setR2ClientObjNames[i]+"\n");
     
     sBuf.append("rloR2ClientType-"+i+"=");
     sBuf.append(rlo.setR2ClientObjTypes[i]+"\n");
    }
    /* Now convert to string to write it out */
    String dataStr= new String(sBuf);       /* data length */
    
    if(!writeTextToFile(fullPath, dataStr))
      return(false);
        
    return(true);
  } /* writeRLOfile */
  
  
  /* ------------------------------------------------------------------ */
  /*  The following abstract methods should be implement in class Reval */ 
  /* ------------------------------------------------------------------ */
     
  /**
   * popupDialog() prompt with message and return response.
   * @param promptMsg is prompt message
   * @param default if press cancel
   * @return result
   */
  abstract String popupDialog(String promptMsg, String defaultAnswer);
  
  
  /**
   * copyFile() - binary copy of one file or URL toa local file
   * @param srcName is either a full path local file name or 
   *        a http:// prefixed URL string of the source file.
   * @param dstName is the full path of the local destination file name
   * @param optUpdateMsg (opt) will display message in showMsg() and 
   *        increasing ... in showMsg2(). One '.' for every 10K bytes read.
   *        This only is used when reading a URL. Set to null if not used.
   * @param optEstInputFileLth is the estimate size of the in;ut file if 
   *        known else 0. Used in progress bar.
   * @return true if succeed.
   */
  abstract boolean copyFile(String srcName, String dstName,
                            String optUpdateMsg, int optEstInputFileLth);
  
  
  /**
   * deleteLocalFile() - delete local file.
   * @param fileName to be deleted on the local file system.
   * @return false if failed.
   */
  abstract boolean deleteLocalFile(String fileName);
  
 
  /**
   * showMsg() - display message in client GUI
   * @param msg message to display
   */
  abstract void showMsg(String msg);
    
         
  /**
   * setWaitCursor() - turn wait cursor on and off
   * @param flag to turn wait cursor on or off
   */
  abstract void setWaitCursor(boolean flag);
  
 
  /**
   * readTextFromFile() - read text from text file.
   * @param fileName full path name of text file
   * @param loadingMsg to display while loading, null if no message
   * @return text if suceed else null
   */
  abstract String readTextFromFile(String fileName, String loadingMsg);
  
  
  /**
   * writeTextToFile() - save text string as text file.
   * @param textFileName full path name of text file
   * @param textReport text to save in file
   * @return true if succeed.
   */
  abstract boolean writeTextToFile(String textFileName, String textReport);
  
  
  /**
   * setRoutput2ClientObjects() - copy data for any entries in the RLO. 
   * It will read R output files and convert them to analysis system
   * dependent data structures and save into the state of that system.
   * @return true if performed any R to system dependent conversions.
   */
  abstract boolean setRoutput2ClientObjects();
  
     
  /**
   * createInputDataFiles() - create any input data files required for 
   * current analysis.
   * Generate input files from data obtained by calling the client MJA API
   * as required and saving the generated files in the inputFilesBasePath
   * folder.
   * @param inputFilesBasePath  where to put generated files
   * @rerturn true if succeed  
   */
  abstract boolean createInputDataFiles(String inputFilesBasePath);
           
   
  } /* end of RevalBase*/
  
  
  
  /* @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ */
  /*  Class RLO to describe .R script LayOuts (RLO) analyses       */ 
  /* @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ */
  
  /**
   * This class is used to specify the .R script LayOuts (RLO) analyses.
   * In addition to the name of the .R script file and menu name, it also
   * encodes the environment required for data input (output) to (from) R
   * as well as actions to be taken after the .R script has been evaluated 
   * by R. Such actions may include bringing data back into the client or 
   * displaying plots generated by R.
   */
  
  class RLO
  {
    private static RevalBase
      rEvalBase;
   
    /* --------- instances -------- */
    
    /** sequence # of description */
    int 
      id;   
    /** Analysis menu name */
    String
      menuName;  
    /** Desired client menu stub. If null or "", then put in 
     * (Plugins | RLO methods submenu) 
     */
    String
      menuStubName;
    /** Name of .R script file */
    String
      RscriptName;    
    /** RLO creation date */
    String
      date;  
    
    /** # of input files if any, 0 if none */ 
    int
      nInputFiles;   
    /** Name of input file if any (if not null) */
    String 
      inputDataFileNames[];
    /** R_DATA_TYPE_xxxx type of input file if any */
    int 
      inputDataTypes[];
    
    /** Process Bits is a bit pattern of selected (R_PB_xxxx) options
     * used during processing
     **/
    int 
      processBits;
    
    /** GenR Bits is a bit pattern of selected (R_GENR_xxxx) options
     * used during .R script generation.
     **/
    int
      genRbits;
       
    /** # of output files if any, 0 if none */ 
    int
      nOutputFiles;   
    /** List of output files if any, null if none */ 
    String 
      outputDataFileNames[];
    /** List of R_FILE_TYPE_xxxx types of output files if any,
     * null if none.
     */
    int 
      outputDataTypes[];    
       
    /** # of output files used to set R to Client data if any, 0 if none */ 
    int
      nSetR2ClientFiles;   
    /** List of output file names used to set R to Client data if
     * any, null if none
     */ 
    String 
      setR2ClientFileNames[];  
    /** List of client object names used to set R to Client data if any, 
     * null if none. E.g., If the object is a gene set (condition list), 
     * then this is the gene set (condition list) name
     */ 
    String 
      setR2ClientObjNames[];
    /** List of R_SET_R2CLIENT__xxxx types of output files if any,
     * null if none.
     */
    int 
      setR2ClientObjTypes[];    
      
   /** Optional script Specific R startup options. These can include
    * things like "--min-vsize=20M", or "--min-nsize=200k", etc. See 
    * Appendix B the "Introduction to R" reference manual for specific
    * options.
    */
    String
      scriptSpecificRoptions; 
    
    
    /**
     * RLO() - constructor for initial database allocation
     * @param rtst (while debugging for access display)
     * @param rEvalBase
     * @param maxAnalyses to set up the database
     */
    RLO(RevalBase rEvalBase, int maxAnalyses)
    { /* RLO */
      this.rEvalBase= rEvalBase;
            
      rEvalBase.maxRLO= (maxAnalyses>0) 
                           ? maxAnalyses : rEvalBase.MAX_ANALYSES;
      rEvalBase.nAnalyses= 0;    
      rEvalBase.analyses= new RLO[rEvalBase.maxRLO];
      rEvalBase.curAnalysis= 0;
    } /* RLO */
    
    
    /**
     * RLO() - constructor instance to create empty RLO
     */
    RLO()
    { /* RLO */
    } /* RLO */
    
    
    /**
     * newRLO() - create new empty R LayOut (RLO) instance to 
     * RLO database.     
     * @return the id number
     */
    int newRLO()
    { /* newRLO */
      if(rEvalBase.analyses==null)
      { /* RLO */
        rEvalBase.maxRLO= rEvalBase.MAX_ANALYSES;
        rEvalBase.nAnalyses= 0;
        rEvalBase.analyses= new RLO[rEvalBase.maxRLO];
      } /* RLO */
      
      RLO rlo= new RLO(); 
      
      rlo.id= rEvalBase.nAnalyses;
      rlo.menuName= null;
      rlo.menuStubName= null;
      rlo.RscriptName= null;
      rlo.date= "";             /* overide if want */
      
      rlo.inputDataFileNames= null;
      rlo.inputDataTypes= null;
      rlo.nInputFiles= 0;
                          
      rlo.processBits= 0;
      rlo.genRbits= 0;
      
      rlo.outputDataFileNames= null;
      rlo.outputDataTypes= null;
      rlo.nOutputFiles= 0;
                           
      rlo.setR2ClientFileNames= null;
      rlo.setR2ClientObjNames= null;
      rlo.setR2ClientObjTypes= null; 
      rlo.nSetR2ClientFiles= 0;
      
      rlo.scriptSpecificRoptions= ""; 
           
      /* Regrow RLO database if need more space */
      regrowRLOdbIfNeeded();        
      
      rEvalBase.analyses[rEvalBase.nAnalyses++]= rlo;  /* push into DB */
      
      return(rlo.id);
    } /* newRLO */
    
    
    /**
     * regrowRLOdbIfNeeded() - grow RLO database if need more space
     */
    void regrowRLOdbIfNeeded()
    { /* regrowRLOdbIfNeeded */
      if(rEvalBase.nAnalyses >= (rEvalBase.analyses.length-1))
      { /* regrow it */
        int 
          oldSize= rEvalBase.analyses.length,
          newSize= oldSize+ 20;
        RLO newAnalyses[]= new RLO[newSize];
        for(int i=0; i<rEvalBase.nAnalyses;i++)
          newAnalyses[i]= rEvalBase.analyses[i];
        
        rEvalBase.analyses= newAnalyses;
      } /* regrow it */
    } /* regrowRLOdbIfNeeded */
    
    
    /**
     * addRLO() - add new R LayOut (RLO) instance to the RLO database.
     * The RLO is a meta-language for specifying the processing interaction
     * between R and client.
     *<P>
     * E.g., the following is an example that exports various types (4) of
     * client data, generates 4 types of output files, and sets the
     * client state from 2 of those files.
     *<P>
     * @param menuName text description of the RLO entry
     * @param menuStubName used by client to put RLO menu entry in a
     *        particular menu.
     * @param RscriptName is the name of the .R file
     * @param inputDataFileNames opt. list of R input data file names
     * @param inputDataTypes corresponding list of R input data file types 
     *        values
     * @param processBits set for use during eval
     * @param genRbits set and used during edit by R script GUI
     * @param outputDataFileNames opt. list of R output data file names
     * @param outputDataTypes corresponding list of R output data file types
     *        values
     * @param setR2ClientFileNames opt. list of action file names to set R 
     *        output data to client state objects
     * @param setR2ClientObjNames opt. list of client action object names to
     *        set R output data to client state objects
     * @param setR2ClientObjType opt. list of client object type values
     *        to set R output data to client state objects
     * @param scriptSpecificRoptions 
     * @return the id number
     */
    int addRLO(String menuName, String menuStubName, String RscriptName, 
               String inputDataFileNames[], int inputDataTypes[],
               int processBits, int genRbits,                          
               String outputDataFileNames[], int outputDataTypes[],
               String setR2ClientFileNames[],
               String setR2ClientObjNames[], int setR2ClientObjTypes[],
               String scriptSpecificRoptions 
              )
    { /* addRLO */
      if(rEvalBase.analyses==null)
      { /* RLO */
        rEvalBase.maxRLO= rEvalBase.MAX_ANALYSES;
        rEvalBase.nAnalyses= 0;
        rEvalBase.analyses= new RLO[rEvalBase.maxRLO];
      } /* RLO */
      
      RLO rlo= new RLO(); 
      
      rlo.id= rEvalBase.nAnalyses;
      rlo.menuName= menuName;
      rlo.menuStubName= menuStubName;
      rlo.RscriptName= RscriptName;
      
      Date dateObj= new Date();
      rlo.date= dateObj.toString();
      
      rlo.inputDataFileNames= inputDataFileNames;
      rlo.inputDataTypes= inputDataTypes;
      rlo.nInputFiles= (inputDataFileNames==null)
                          ? 0 : inputDataFileNames.length;
                          
      rlo.processBits= processBits;
      rlo.genRbits= genRbits;
      
      rlo.outputDataFileNames= outputDataFileNames;
      rlo.outputDataTypes= outputDataTypes;
      rlo.nOutputFiles= (outputDataFileNames==null)
                           ? 0 : outputDataFileNames.length;
                           
      rlo.setR2ClientFileNames=setR2ClientFileNames;
      rlo.setR2ClientObjNames= setR2ClientObjNames;
      rlo.setR2ClientObjTypes= setR2ClientObjTypes; 
      rlo.nSetR2ClientFiles= (setR2ClientFileNames==null)
                           ? 0 : setR2ClientFileNames.length;
      
      rlo.scriptSpecificRoptions= scriptSpecificRoptions;  
           
      /* Regrow RLO database if need more space */
      regrowRLOdbIfNeeded();       
           
      rEvalBase.analyses[rEvalBase.nAnalyses++]= rlo;   /* push into DB */
      
      return(rlo.id);
    } /* addRLO */
    
    
    /**
     * setRLO() - set R LayOut (RLO) instance to the RLO database.
     * The RLO is a meta-language for specifying the processing interaction
     * between R and client.
     *<P>
     * E.g., the following is an example that exports various types (4) of
     * client data, generates 4 types of output files, and sets the
     * client state from 2 of those files.
     *<P>
     * @param menuName text description of the RLO entry
     * @param menuStubName used by client to put RLO menu entry in a
     *        particular menu.
     * @param RscriptName is the name of the .R file
     * @param inputDataFileNames opt. list of R input data file names
     * @param inputDataTypes corresponding list of R input data file types
     *        values
     * @param processBits used during eval
     * @param genRbits set and used used during edit by R script GUI
     * @param outputDataFileNames opt. list of R output data file names
     * @param outputDataTypes corresponding list of R output data file types
     *        values
     * @param setR2ClientFileNames opt. list of action file names to set R 
     *        output data to client state objects
     * @param setR2ClientObjNames opt. list of client action object names to
     *        set R output data to client state objects
     * @param setR2ClientObjType opt. list of client object type values
     *        to set R output data to client state objects
     * @param scriptSpecificRoptions 
     * @return the id number
     */
    boolean setRLO(int rloID,
                   String menuName, String menuStubName, String RscriptName,
                   String inputDataFileNames[], int inputDataTypes[],
                   int processBits, int genRbits,
                   String outputDataFileNames[], int outputDataTypes[],
                   String setR2ClientFileNames[],
                   String setR2ClientObjNames[], int setR2ClientObjTypes[],
                   String scriptSpecificRoptions
                   )
    { /* setRLO */
      if(rloID<0 || rloID>=rEvalBase.nAnalyses)
        return(false);
      
      RLO rlo= rEvalBase.analyses[rloID];
      
      rlo.id= rloID;
      rlo.menuName= menuName;
      rlo.menuStubName= menuStubName;
      rlo.RscriptName= RscriptName;
      
      Date dateObj= new Date();
      rlo.date= dateObj.toString();
      
      rlo.inputDataFileNames= inputDataFileNames;
      rlo.inputDataTypes= inputDataTypes;
      rlo.nInputFiles= (inputDataFileNames==null)
                          ? 0 : inputDataFileNames.length;
                          
      rlo.processBits= processBits;
      rlo.genRbits= genRbits;
      
      rlo.outputDataFileNames= outputDataFileNames;
      rlo.outputDataTypes= outputDataTypes;
      rlo.nOutputFiles= (outputDataFileNames==null)
                           ? 0 : outputDataFileNames.length;
                           
      rlo.setR2ClientFileNames=setR2ClientFileNames;
      rlo.setR2ClientObjNames= setR2ClientObjNames;
      rlo.setR2ClientObjTypes= setR2ClientObjTypes; 
      rlo.nSetR2ClientFiles= (setR2ClientFileNames==null)
                           ? 0 : setR2ClientFileNames.length;
      
      rlo.scriptSpecificRoptions= scriptSpecificRoptions;           
          
      return(true);
    } /* setRLO */
    
    
    /**
     * rmvRLO() - remove the RLO from the analyses database
     ** This removes the .rlo file from the RLO/ directory and
     * the .R script file from the R/ directory.
     * @param rloIdToRemove to remove
     * @return true if removed
     */
    boolean rmvRLO(int rloIdToRemove)
    { /* rmvRLO */         
      for(int i=0;i<rEvalBase.nAnalyses;i++)
        if(rEvalBase.analyses[i].id==rloIdToRemove)
        { /* remove from the list */
          
          /* [1] Found it - go Remove RLO/*.rlo and /R/*.R files */      
          try
          { /* Remove RLO/*.rlo and /R/*.R files */
            String
              rsFile= rEvalBase.analyses[i].RscriptName,
              rloFile= rsFile.substring(0,rsFile.length()-2)+".rlo",
              fullRscriptFile= rEvalBase.RscriptBasePath + rsFile,
              fullRloFile= rEvalBase.RLObasePath + rloFile;
            
            /* [1.1] Ask user if this is the one they want to delete. */
            String
              areYouSure= rEvalBase.popupDialog("[yes|no]. Delete "+rsFile+
                                                " and "+ rloFile +
                                                " files? Are you sure? ", 
                                                "no");      
             if(!areYouSure.equalsIgnoreCase("yes"))
               return(false);               /* don't bother */
            
            /* [1.2] Delete R script */
            File fR= new File(fullRscriptFile);
            fR.delete();
            
            /* [1.3] Delete RLO file */
            File fRLO= new File(fullRloFile);
            fRLO.delete();
            
            /* [1.4] Remove from menu, shift list down by 1 from [i] to 
             * [nAnalyses-1].
             */
            for(int x=i; x<rEvalBase.nAnalyses; x++) 
              rEvalBase.analyses[x]= rEvalBase.analyses[x+1];
            
            rEvalBase.nAnalyses--;  /* since deleted, decrease by 1 */
            
            /* [1.5] Remove last object from the list by setting to null */ 
            rEvalBase.analyses[rEvalBase.nAnalyses]= null;
            return(true);
            
          } /* Remove RLO/<>.rlo and /R/<>.R files */
          catch(Exception e)
          { 
            System.out.println(
                  "rmvRLO(): Error with deleting RLO file # "+ i);
            return(false);
          }
            
        }/* remove from the list */
      
      return(false);  /* not found/error */
    } /* rmvRLO */
    
    
    /**
     * clearRLOdb() - clear list of R LayOuts analyses in the database
     */
    void clearRLOdb()
    { /* clearRLOdb */
      rEvalBase.nAnalyses= 0;
    } /* clearRLOdb */
    
    
    /**
     * getRLOidByRscriptName() - get the current RLO analysis method id by
     * RscriptName
     * @param rsName is the RscriptName to lookup in the database
     * @return current RLO object id, -1 if not found
     */
    int getRLOidByRscriptName(String rsName)
    { /* getRLOidByRscriptName */
      for(int i=0;i<rEvalBase.nAnalyses;i++)
        if(rsName.equals(rEvalBase.analyses[i].RscriptName))
          return(i);   /* found it */
      return(-1);      /* failed */
    } /* getRLOidByRscriptName */
    
    
    /**
     * setCurrentRLO() - set the current RLO analysis by id
     */
    void setCurrentRLO(int id)
    { /* setCurrentRLO */
      rEvalBase.curAnalysis= id;
    } /* setCurrentRLO */
    
    
    /**
     * getCurrentRLO() - return current RLO
     */
    RLO getCurrentRLO()
    { /* getCurrentRLO */
      return(rEvalBase.analyses[rEvalBase.curAnalysis]);
    } /* getCurrentRLO */
    
    
    /**
     * getListofRLOscriptNames() - get list of all R script names
     * @return list of RLO R script names
     */
    String[] getListofRLOscriptNames()
    { /* getListofRLOscriptNames */
      String sRSL[]= new String[rEvalBase.nAnalyses];
      int n= 0;
      for(int i=0;i<rEvalBase.nAnalyses;i++)
        if(rEvalBase.analyses[i]!=null &&
           rEvalBase.analyses[i].RscriptName!=null)
          sRSL[n++]= rEvalBase.analyses[i].RscriptName;
      
      String rScriptList[]= new String[n];
      for(int i=0;i<n;i++)
        rScriptList[i]= sRSL[i];
      
      return(rScriptList);
    } /* getListofRLOscriptNames */
    
    
    /**
     * getListofRLOmenuNames() - get list of all menuNames
     * @return list of RLO menu names
     */
    String[] getListofRLOmenuNames()
    { /* getListofRLOmenuNames */
      String sML[]= new String[rEvalBase.nAnalyses];
      int n= 0;
      for(int i=0;i<rEvalBase.nAnalyses;i++)
        if(rEvalBase.analyses[i]!=null &&
           rEvalBase.analyses[i].menuName!=null)
          sML[n++]= rEvalBase.analyses[i].menuName;
      
      String menuList[]= new String[n];
      for(int i=0;i<n;i++)
        menuList[i]= sML[i];
      
      return(menuList);
    } /* getListofRLOmenuNames */
    
    
    /**
     * getListofRLOids() - get list of all IDs
     * @return list of RLO ids
     */
    int[] getListofRLOids()
    { /* getListofRLOids */
      int idList[]= new int[rEvalBase.nAnalyses];
      for(int i=0;i<rEvalBase.nAnalyses;i++)
        idList[i]= rEvalBase.analyses[i].id;
      return(idList);
    } /* getListofRLOids */
    
    
    /**
     * getRLObyMenuName() - get the RLO by menuName
     */
    RLO getRLObyMenuName(String menuName)
    { /* getRLObyMenuName */
      for(int i=0;i<rEvalBase.nAnalyses;i++)
        if(rEvalBase.analyses[i].menuName.equals(menuName))
          return(rEvalBase.analyses[i]);
      return(null);
    } /* getRLObyMenuName */
    
    
    /**
     * getRLObyRscriptName() - get the RLO by RscriptName
     */
    RLO getRLObyRscriptName(String RscriptName)
    { /* getRLObyRscriptName */
      for(int i=0;i<rEvalBase.nAnalyses;i++)
        if(rEvalBase.analyses[i].RscriptName.equals(RscriptName))
          return(rEvalBase.analyses[i]);
      return(null);
    } /* getRLObyRscriptName */
    
    
    /**
     * getRLObyID() - get the RLO by id
     * @param id to use in searching analyses database
     * @return
     */
    RLO getRLObyID(int id)
    { /* getRLObyID */
      for(int i=0;i<rEvalBase.nAnalyses;i++)
        if(rEvalBase.analyses[i].id==id)
          return(rEvalBase.analyses[i]);
      return(null);
    } /* getRLObyID */

    
  /** 
   * getRLOoutFile() get the nth Output Data file by out file type.
   * Search outputDataTypes[] entries in the current RLO
   * analyses[curAnalysis] instance.
   * @param lookForFileType is one of R_FILE_TYPE_xxxx values
   * @param nth is the nth instance to return (counting from 1 - not 0!)
   * @return file name if found, else null if failed.
   * @see #getCurrentRLO
   */
   String getRLOoutFile(int lookForFileType, int nth)
   { /* getRLOoutFile */    
     RLO a= getCurrentRLO();
     if(nth==0 || a==null || a.nOutputFiles==0)
       return(null);
    
     int k= 0;    
     for(int j=0;j<a.nOutputFiles;j++)
     { /* look for the first report file name */
       if(a.outputDataTypes[j]==lookForFileType)
       { /* Found a report file name - set global and get report */
         k++;
         if(k==nth)
         {
           String sFile= a.outputDataFileNames[j];
           return(sFile);
         }
       }
     } /* look for the first report file name */
     
     return(null);
   } /* getRLOoutFile */ 
   
    
  /** 
   * getRLOinputFile() get the nth Input Data file by input file type.
   * Search inputDataTypes[] entries in the current RLO
   * analyses[curAnalysis] instance.
   * @param lookForFileType is one of R_FILE_TYPE_xxxx values
   * @param nth is the nth instance to return (counting from 1 - not 0!)
   * @return file name if found, else null if failed.
   * @see #getCurrentRLO
   */
   String getRLOinputFile(int lookForFileType, int nth)
   { /* getRLOinputFile */    
     RLO a= getCurrentRLO();
     if(nth==0 || a==null || a.nInputFiles==0)
       return(null);
    
     int k= 0;    
     for(int j=0;j<a.nInputFiles;j++)
     { /* look for the first report file name */
       if(a.inputDataTypes[j]==lookForFileType)
       { /* Found a report file name - set global and get report */
         k++;
         if(k==nth)
         {
           String sFile= a.inputDataFileNames[j];
           return(sFile);
         }
       }
     } /* look for the first report file name */
     
     return(null);
   } /* getRLOinputFile */
    
  } /* end of RLO */
  